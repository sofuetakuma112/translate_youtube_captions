Hi there and welcome to a project video where you'll build and deploy a full stack chat application with authentication and Twilio Sms notifications with direct and group chats, emojis, and reactions.

Built-in gif support the ability to edit and delete messages, specialized commands, and much more.

This fully responsive medical pager is the best chat application that you can currently find on Youtube.

In this video, you'll work with modern technologies such as Javascript, Node, React, and Stream.

You'll learn advanced React best practices such as folder and file structure, custom hooks, and even React context api creating the user interface for the login and register page and for the entire chat feed.

You'll also learn how to work with Stream api.

Stream is the number one chat messaging platform that allows you to build scalable and completely custom chat applications using their apis.

We're also going to use Twilio to send a real Sms notification to a user when he's offline.

The chat app we'll be building is not a general purpose chat, it is a medical pager themed chat application.

After watching this video, you'll be able to build any chat application you can think of, from clones of popular apps like Whatsapp, Discord, and Slack to the fully custom messaging platforms.

I initially planned on putting this as a paid course, but I later decided to release it completely free for you guys here on Youtube.

So to support this video, leave a like comment and subscribe.

It shouldn't take more than a few seconds and I really appreciate it.

In the end, we're also going to deploy the application so that you can share it with your friends, put it on your portfolio, and get a job.

Let's get straight into it.

Before we begin, please allow me to give you a quick demo of the application.

As I've mentioned, the chat app we'll be building is not a general purpose chat.

It's a medical pager themed chat application.

It's an app where doctors and medical personnel can communicate to ensure that they're always up to date with what's happening in their divisions of the hospital.

of course, this is just one example of how Versatile Stream is.

You can build anything you'd like clones of popular applications like Discord or Slack, a coding community chat, custom direct messaging app, or anything you can think of.

This application consists of two parts: a login and registration form, and a chat dashboard.

So let's check out the login form.

When a doctor or a person is signing up for the first time, they'll have to enter their full name, username, a phone number as well so that we can send Sms notifications, avatar url, and a password.

Once they sign up for the first time, they'll be added to our database.

Then they can simply sign in.

For example, Dr.

Miller, We enter the password and click sign in.

As simple as that, we are right inside of our application.

As you can see, it has plenty of features.

There are a lot of chat tutorials on Youtube, but I've never seen this many features on a video.

Of course we can send messages, but we can also add reactions to those messages.

There we go.

We can also reply in treads to a specific message, so let's say hello there.

And like that we have built-in threads for replies as you can see right there.

We can also send gifs that's something that's pretty new.

so if you just type forward slash giphy and try to do something like hi, it's going to give you all the random gifs that you can send right inside of the chat.

You can also send emojis images and you can also embed Youtube videos so that you can play them right from inside of your chat.

We also have a search so you can search for different channels and users, But more importantly, the entire chat app is completely mobile.

Responsive! As you can see, it has that native like feeling.

It feels like it is a mobile application and if you click right here, you'll see a nice little animation that gives you access to all the channels and direct messages.

Usually it would be extremely hard to add so many features to an application like this in one video, but thankfully we are using Stream.

As I've mentioned, stream is the number one chat messaging api infrastructure.

It allows you to build scalable and custom chat applications extremely easily.

We can explore their demos.

We have a social Messenger example, the team collaboration one which is similar to ours.

Customer support even live stream chat applications are covered.

and we also have virtual events if you want to chat while watching a specific stream, I think you can see how powerful stream is and stream is exactly what we'll be using in this video.

With that said, I think you're pretty excited to start coding this application.

So let's dive into coding right away.

Let's start by creating an empty folder on our desktop.

I'm going to call it Medical Dash pager of course, feel free to call it a chat application or anything else you'd like.

Once we have our folder, I've also opened an empty Visual Studio code window of course, feel free to use any code editor of choice.

In this case, we'll be sticking with Visual Studio code, so simply drag and drop the folder into your code editor.

Now that you have done that, you can simply go under view and then terminal.

We're going to use this terminal to initialize our React application.

Let's clear it and now we have to create two different directories.

So let's create a new folder.

This one is going to be called client for our client-side React front-end application and the other one is going to be called Server.

This is going to be for our backend node.js Server.

In this case, we can start off with creating the client side.

So let's Cd into client and then finally run Mpx Create Dash React Dash App Dot Slash.

That slash is going to make sure to install our React application right inside of the client folder.

Now let's click enter.

We're gonna wait a few minutes and I'll be right back.

There we go.

Our application has been initialized.

We can clear our terminal to start off.

Let's go inside of our client folder and delete the source folder.

Now, every React application needs to have an index.js where we need to import React from React.

We also need to import React Dom from React Dom.

Then we can import the app which we haven't yet created that's going to be import app from that slash App.

And finally, we can say React Dom dot Render and we can render our application by specifying document.getelementbyid and that's going to be Root.

Even though I'm sure that most of you understand what this does, let me quickly explain it.

Our entire React application is going to be inside of this component and we're going to hook that component onto the root div and where that would div is is right inside of the public and then index.html This file might seem a bit weird, but if we properly condense it like this, remove some comments, some more comments, and even more comments and this you'll see that this is a simple index Html page with only one div and inside of here our entire React application will be while we're here.

We can also change this from React app to something like Medical Pager or feel free to change it to whatever you'd like.

Great! Now we can go back to our index or more specifically, we can start creating our app.jsx component inside of here.

I'm going to use an Rafce, which is React arrow function with export, so this is simply going to create the entire boilerplate for the component.

You can use that same command by installing Es7, React, Redux Craftql snippets.

so if you install that extension, you'll have plenty of these snippets that you can call to make your work easier.

With that said, we have nothing more than a simple functional component inside of there.

For now, let's simply create an H1 and say Medical Pager Chat application.

Great! Now we have our index, We have our app.js and the last thing we need is to install all of the necessary dependencies.

There are only three most important dependencies that we're gonna need.

so you can say Npm Install and these are gonna be Stream Dash Chat Also, Stream Dash Chat Dash, React, and finally Universal Dash Cookie.

We're gonna use cookies to save the user information in the browser if you press enter.

This is going to install these three dependencies.

Not a lot, only three, but these are going to help us to create our entire chat application while this is installing.

I wanted to quickly show you that we have the entire code for this project under Project Medical Pager on Github.

The link is going to be down in the description if you ever get stuck or something is not working as it should.

Definitely make sure to check it out and compare the code, even clone it if you need to.

If you like the project, definitely make sure to leave a star as well.

With that said, while our dependencies are still installing, we can go ahead to Stream and create a free account.

We're definitely gonna need it.

The link to stream is going to be down in the description.

Now that we're here, let's click try for free inside of here.

You'll of course have to enter your email also, your organization name or your full name.

I'm just gonna do Javascript, Dash Mastery and finally your password.

Now that you've entered all the information simply click, Get started and with that you're already welcome to Stream on the top.

Right you can click go to Dashboard.

There we go.

Our demo production application has been created, There is our key and our secret which we're gonna use soon enough to create our entire chat application.

For now, you can leave this page open and let's go back to our code editor.

Our packages have been installed and we are ready to start creating this app.

So let's close this and this and we only need app.jsx for now inside of here.

We'll have to import a few things that we're going to use later on to connect to stream chat.

So let's say import stream chat from Stream Dash Chat and we're going to also need the React component which is going to be import chat in curly braces from Stream Chat React later on in our app.

We're also going to use cookies so we can say import cookies from Universal Cookie.

Great! Now we have all the imports right here to set up our chat.

We're gonna need an api key so we can say const api key is going to be equal to and now we need to find this key inside of our stream dashboard.

As you can see, the key is right here.

You can simply copy it, go back and paste it right here.

We're going to use this to initialize our chat.

now that we have that we're going to remove this H1 and we're going to give a class name to this Div Div class name is going to be equal to a string of app, underscore, underscore wrapper, and inside of there we're going to render dot chat.

Application chat is not going to be a self-closing tag.

We're gonna put something in there.

More specifically, we have to put the channel container and the channel list container.

These are all going to be components that we are going to create, so let's simply specify them.

Right now, we're going to have a channel list container, which is going to be a self-closing component and below that, we're also going to have channel container Again, we don't yet have those components, but we're going to create them right away.

Also, for this chat to work, we need to create an instance of a stream chat so we can do that right here above our component.

We can say const client is equal to stream chat dot, get instance and then we can call that as a function and pass in the api key.

Finally, we can specify client is equal to client We can also choose a theme of our application.

In our case, I'm going to say theme is equal to team lite.

This is going to make our chat application look a bit better, right out of the box.

Okay, we've set some things up, but we don't have access to these components, so what might be best is to create a components folder right away and to create the basic structure of all the components that we're going to have.

There are going to be quite a lot.

but if we nail down all the components and the imports at the start of the video, it's going to be so much easier to simply keep using them later on.

So, inside of the components folder, we can first create two components: the channel container and the channel list container.

So right here: New File Channel Container.jsx and also Channel List Container.jsx and you guys often ask me what is the difference between Js and Jsx, There is none.

I just prefer to use Jsx for whenever a file is a React component.

That way, it's easier to differentiate them.

Okay.

With that said, we can create a simple React Arrow function component and we can specify the name of that component like this.

Now that we have it, it's going to be simple to simply copy and paste this across all the components we are about to create.

We can paste it here as well, and you can double click the name of the component, press Ctrl F, and then simply change it to something else.

In this case, that's going to be Channel List Container.

Great! The two components we need right now are done.

So if we go to App.js we can simply try to import them.

like import.

That's going to be channel like this.

Let me just copy it.

Channel List Container I misspelled it there, so let's fix it.

Channel List Container from dot slash components slash Channel List Container and the other one is simply going to be Channel Container.

Great.

As you can see, we only have two, so this is fine.

Two imports, two lines, but later on, we're going to have so many more imports and it's going to look like something like this.

This is not what we want.

So we're going to create a system for imports that's going to make her life easier in the long run.

If we go in our components folder and create a new index.js file inside of there, we'll be able to export all the components automatically.

We can do that by saying export curly braces default as and then the name of the component something like Channel Container from and then we point to that file.

We can now duplicate this and inside of here this is going to be Channel List Container Great! Now these components are being exported straight from the components folder and inside of our app.

We can say something like this: import now in curly braces that's going to be Channel List container and also Channel Container straight from dot slash components.

We don't need to add any file names because everything is being exported from there and now all of the imports are being done in one line.

There we go again.

I know this was a bit of work, but it's going to make our life so much easier later on.

At this point, we should already see something on the screen.

So let's open up our terminal by going to view terminal, clearing the console, and simply running Npm start.

This is going to start our application on localhost 3000. There we go.

Our application started, but as you can see, we don't have anything on the screen yet besides these two text elements.

so let's go ahead and add some styles to fix that at the end.

This application is going to look great, but to keep this video focused and extremely informational only about building chat applications, I'm going to provide you with the entire Css style sheet.

We're going to use the Bem methodology.

Bem is a Css methodology that kind of helps everybody understand how Css class names are made.

We first have the block and then we have underscores with the element and then finally we have modifiers.

So you're going to learn how to write these class names, but I'm going to provide you with the styles to create the styles.

We can go inside of our source folder and create a file called app.css inside of there.

We're going to paste our styles.

All of the styles for our application are here.

You can find these styles and all of the links mentioned in this video are going to be right below in the description.

So just make sure to check that gist and simply copy and paste these styles right into the app.css Then we can go inside of our app.jsx and right inside of here.

You can simply say import dot slash App.css This is going to import all of our styles and we'll be able to use these class names to immediately apply them.

Great! Let's check out if this made any changes already.

No, nothing special that we can see.

It just removed some margins and made everything appear in a list.

But of course as we add more styles and class names, this application will start to look phenomenal.

With that said, the basic layout of our application has been created.

Now is the time that we keep adding more Jsx, more structure.

But more importantly, keep getting into the logic of how we can implement our chat application.

Let's start with creating our Channel List container, which is basically our sidebar.

Now let's first import a few things from Stream Chat React.

We can import a Channel List component and also use Chat context that's going to be coming from Stream Dash, Chat, Dash, React.

Then we can import a few components that we are going to create ourselves something like Channel Search, also, Team Channel List, and finally Team Channel Preview.

These components will be coming from dot slash from R Components, and finally in this component as well.

We're going to use cookies so we can say import cookies from Universal Cookie.

Great! Now that we have that, let's start creating our Jsx for the Sidebar.

So above our current Channel list component, we can create a new functional component which is going to be called Sidebar.

Our sidebar can have an instant return, so just parentheses right there and then inside of there we can start creating some Jsx First, we're going to have a Div that's going to have a class name equal to channel Dash list, underscore, underscore, Sidebar.

And inside of that div, we're going to have one more Div which is going to have a class name which is going to be equal to Channel Dash list, underscore, Underscore, Sidebar, Underscore, Underscore, Icon 1, and just one more Div inside of it.

This div is going to have a class name equal to Icon 1, underscore, Underscore, Inner Great.

Finally, we have that icon.

So that's going to be an image, which is a self-closing tag.

It's going to have a source Src equal to hospital icon.

This is the icon that we're going to import right away, and it's going to have the alternative text equal to hospital.

And finally, it can have width equal to 30..

Great! Now that we're here, let's also import that icon just at the top.

We can say import hospital icon from dot slash Assets slash Hospital dot Png.

As you can see, we don't yet have the Assets folder, so let's create it right now.

Above the components right inside of the source folder, you'll be able to simply paste the assets folder.

As with all the other files mentioned, the assets folder is going to be linked in the description Great, as you can see that assets contain a few Svgs which are going to be our icons, and then it also contains a few Png icons, screens, and images.

Great! Now we can use that icon.

now.

I'm going to copy this sidebar icon 1 and duplicate it below.

This time it's going to be Sidebar Icon 2.

Icon One enter is going to remain the same, but this time we're gonna have a logout icon.

Also, the alt is going to be equal to log out and the width is going to be 30 pixels.

For now, we can simply duplicate this line and say import logout icon from and that's going to be logout.png Great! This is it for our sidebar.

Now we can go inside of our Channel list container.

I'm gonna make this div a simple react fragment and then inside of there we're gonna render that sidebar as a self-closing tag, make sure it's spelled correctly and there we go.

Of course we could have put the entire code right there, but as our code is going to get more complicated, we want to differentiate different parts of Jsx to make it easier for people to read.

Now that they've done that, let's go into our browser and let's check it out.

As you can see, this already looks just a bit better.

Now we no longer have the Channel list container which is actually just the navigation bar and now we're displaying it.

Now let's keep adding more things to our navigation bar.

The second thing we're going to add is going to be another functional component called Company Header.

Again, just a functional component with an instant return, just parentheses and then inside of there we're gonna have a div that div is going to have a class name equal to Channel Dash List, underscore, Underscore header, and inside of there, we're gonna have just one paragraph tag, which is going to have a class name equal to Channel Dash list, underscore, underscore header, and then underscore underscore text.

Again, this is going to be a medical pager, so we can specify that there.

Finally, we're gonna render that company header right inside of Div, below the sidebar, so we can create that div, give it a class name, which is going to be equal to Channel Dash list, Underscore, Underscore List, Underscore, Underscore wrapper, and right inside of that list, we can render our company header.

Let's save it and take a look.

As you can see, we added this entire portion and just below, we'll be able to display our search and all of the channels.

So as you can see, Stream is not simply building everything out for you, it's giving you access to the apis which are going to allow you to search channels, create channels, send messages, and everything else.

but you actually create the Jsx, the layout, and the styling for your application.

Now, let's implement these three most important components: the Channel Search theme, Channel List, and Team Channel Preview.

We can start with Channel Search.

I'm going to go to our components folder, create a new file called Channel Jsx.

Of course, as soon as I created, I'm gonna duplicate one more line inside of our index, and I'm gonna add our Channel Search right there.

Don't forget to do that because this import right here is not going to work Then With that said, how do we implement a Channel Search? Well, our Channel search is going to be a functional component, so we can simply import React, create that functional component, and export it alongside React.

We're going to also need use State and use Effect Hooks and we're going to need the context from Stream Chat React so we can say use Chat context and that's going to be coming from Stream Chat React inside of here.

We're also going to have one icon so we can say import in curly braces search icon and that's going to be coming from dot slash Assets.

Great! Now let's start creating the Jsx for our search.

This Div is going to have a class name equal to Channel Dash Search Underscore Underscore Container Inside of that Div, we're going to have yet another Div, and this Div is going to have a class name equal to Channel Dash Search Underscore, Underscore Input Underscore Underscore Wrapper Now inside of that, we're gonna have one more Div and this Div is finally going to have a class name of Channel Dash Search Underscore Underscore Input Underscore Underscore Icon in there.

we can place our Svg icon by saying search icon and calling it like a self closing tag.

Now, of course, below this Div, we can actually place our input.

So I'm going to say input and it's going to have its own class name which is going to be equal to channel Dash Search Underscore Underscore Input Underscore underscore Text Of course we'll have to provide it with a few more properties things like a placeholder equal to search, a type equal to text and finally, we have to give it a value and also the on change.

Now that we can see, we have a lot of props on this component, I'm gonna simply space them out, each in its own row.

Okay, so as we said, input has two most important things and those are value and on change.

So what value is this input going to have? Well, it's going to be query the search query we're looking for and what are we going to do on change.

Well, we're going to call the on search function So just above, let's create that query state field.

I'm going to say const open pair of square brackets and that's going to be query and set.

Query is equal to use state and at the start we can set it up to be empty string below that let's create that method for getting our search So we can say const on search is equal to we're going to get an event there and what we can do is simply first call the event.preventdefault We have to do this every time that you have an input or buttons or things like that because the usual browser behavior is whenever you click, submit or something similar to reload the page we're working with, React, we want everything to be reactive, instantaneous, and we want to prevent that.

So that is what this line is doing.

Now that we have that, what we can do is, we can also set the loading to be equal to true.

Of course, the loading is going to be another state, so I'm going to duplicate this one and simply create a state field of loading and set loading at the start.

Our loading is going to be set to false, so we can do that right here.

Now that we've set the loading to true, we can finally set the query.

So what exactly are we searching for? Well, we're searching for event.target.value Remember, in React, whenever you type something into the input, you get the value of that text under the event target value.

And finally, the last thing we want to do is we want to get the chat channels.

For that, we can call a new function called Get Channels to that function.

We of course also have to provide the searched query so we can simply say event target value one more time.

Of course you can see this function is not yet existent.

so let's create it.

Const: Get channels.

This function is going to be an async function because we have to wait for the channels to be fetched.

Now that we have that it's going to accept the text we're searching for and inside of here, we can open a try and catch block.

We'll try to get the actual channels.

If we cannot, we'll go to the error.

So if we have an error, we can simply set the query to be equal to nothing.

Just reset the search.

But how exactly are we gonna get the channels? Well, we have to do that later on because we haven't yet set up our entire chat application.

So I'm simply going to add a to do right here.

And I'm going to say Fetch Channels.

By the way, if you're wondering, why is this comment orange, That's because I'm using an extension called Better Comments.

I find it to be pretty useful if you want to have a to-do you can just type to do.

or you can make something green like this, or even add an exclamation mark to make it red.

so it's just coloring the comments.

Basically, we have our to-do here.

That's something we have to do later.

Of course we have to do it once we actually have the logged in user to the chat and once we have a few chat messages, direct messages, channels, and so on.

So for now, the important part is that our Jsx is done later on.

we're gonna implement the logic before taking a look in the browser.

I just noticed that I have a typo here.

that's gonna be assets Now that we fixed that part, let's actually use our Channel search inside of our Channel List container.

We are importing it, but if you scroll down, you'll notice that we're never using it.

So to use it, we can call it as a self-closing component right here.

So to use it, we can call it just below our company header as a self-closing component.

Let's save it and take a look.

there we go.

Our search bar with the search icon is right in here.

Of course if you start typing something, it's not gonna work because we don't have users yet.

So now let's create the layout for the channels and for direct messages and then we'll move on to the channel container.

Next component on our list is the Team Channel list.

So inside of the components, let's just create it theme, channel list, dot Jsx, and we're again going to use the Rafce to simply create a functional component inside of here.

We won't have to import a lot of things, this is just a list.

So what we can do is simply import add channel.

This is going to be an Svg icon from dot slash Assets and that's going to be it.

So now let's create the Jsx off our channel list.

So right inside of here, we'll have a lot of variables that we can work with and how are we gonna pass them? Well, they're going to be passed for us by using Stream.

So let's go back to our channel container.

We named our component team Channel list, but notice that we also have the channel list coming from Stream Chat React.

So if we scroll down, let me show you how we're going to call it first, just below the company search we're going to call the channel list.

Channel list is a self-closing component, but it accepts a few props.

First, it accepts filters.

Filters is an object that's going to allow us to filter some messages.

Then we're also going to have the channel render filter function.

This is a function that we can call and based on that, we can also pass on filters.

So again, right now, I'm going to leave this empty.

And finally, the most important thing is the list.

So we can say list with a capital L.

That's an important part.

That means that we want to render a custom list.

We can do that by providing a callback function.

We get access to all the list props right inside of here.

And finally, we can render the component we've created, which is called the team Channel List.

So basically what's happening is Stream allows you to get a channel List component right out of the box.

It's going to look good, but we still want to create our own custom team Channel list and that's exactly what we're doing.

So we're getting all of these list props and we can simply spread them right here.

So that's going to be dot dot list props inside of the curly braces.

That means that our custom component will get all the props that the channel list would usually get using stream.

Now, when it comes to filters, I'm simply going to put that as an empty object right now.

And for the channel filter function, we're gonna just leave that as an empty callback function.

Just like this.

Let's save it.

and now let's make use of all of these props we're passing to our team channel list going right in here.

Now we can get access to them.

The first prop that every single React component has is the children property.

Then we're going to have the error which we're going to set to false at the start.

We also have the loading and we also have the type that type is going to be dependent on are we in group chats or just direct messages? So let's first handle the errors at the top.

We can say if error we're going to return something, but before we have to check out the type, if the type is equal to team, then we want to return an error message like this.

Right Here, we'll specify the Jsx and if it's not team, we simply want to return null.

It doesn't exist.

So how is the Jsx for this going to look like? Well, right here.

let's create a div and that div is going to have a class name which is going to be equal to Team Dash Channel Dash List Below that we're gonna have one paragraph tag so P tag that's gonna have a class name equal to Team Channel list, underscore, underscore message and inside of there we can simply say Connection Error Please wait a moment and try again.

Great, That's about it for the error.

Now we can actually create the loading part so just below this.

If we're going to create if loading inside of there, we're also going to have a return statement and let's return the same div that we already have.

So we're going to copy the div with the paragraph and paste it right here.

This one is going to be Team Channel List Team Channel List message, but we're going to add loading to this so it's going to be space loading.

and then finally, instead of the error message, we're going to open a dynamic block and we're going to say if type is triple equal to team.

In that case, we want to say channels else we want to say messages And then finally, we're going to add loading dot dot.

This is our loading.

Now that we've handled the error state and the loading state, we can actually show our lists.

So this div is going to have a class name equal to Team Dash Channel Dash List below that we're going to have one more Div and this div is going to have a class name equal to Team Dash Channel Dash List, Underscore Underscore Header and as we had so far, we're going to have one more paragraph.

So let's create a paragraph tag and this P tag is going to have a class name equal to Team Dash Channel Dash List Underscore, Underscore header, Underscore Underscore Title A lot of underscores there.

So what we can say is we can simply copy this dynamic block, paste it here, and if it is a team chat, in that case, we can simply say channels Else we can say direct messages.

That's about it and below this.

Later on, we're going to have a button to add the channel.

Right now.

we're going to leave that blank, but later on you know it has to be here.

And finally, outside of this first Div, we want to render the children everything that has been passed to our Team Channel list.

We want to render it right here.

Great.

With that, we are almost done with our Team Channel List component.

Let's go into our index.js and let's export it from there so that we can use it in our Channel List container.

That's gonna be Team Channel List.

Now that we are exporting it, let's see where we are using it.

That's going to be in the Channel List container.

as you can see at the top right here we're importing it and we're using it, right here.

and passing all the list props.

But remember, we also have to pass the type.

The type is going to be equal to team.

We have to do that specifically because below we're going to have this exact same channel list, but the type is going to be messaging for direct messages so we need to be able to differentiate them.

Let's save it and take a look.

There we go.

Right now we have connection error.

Please wait a moment.

That makes sense because we haven't yet connected anything, but we have it here for later on Now We also have to implement the last component in this file which is the theme Channel Preview.

So let's create that component called Team Channel Preview dot Jsx.

Not to forget, let's go to the index and let's quickly export it from there.

That's going to be Team Channel Preview Back in here we can run rafce to get our simple code running.

The situation with our Team Channel preview is going to be the same.

as with our Team Channel list, we're going to get a lot of props.

They're going to get passed into it.

So by going here we can simply specified one more prop which is going to be called Preview and that is going to be equal to a callback function with an instant return.

Right there we get preview props and now we can render our own component which we called Team Channel Preview.

Now we can spread those props.

So dot Preview Props and finally we also have to pass.

the type which is going to be the same type is equal to team.

Now that we have all the necessary components in our Team Channel Preview, we can go back and we can use them right inside of our props.

The props we need for now are gonna be channel and also type great inside of this component.

We'll also use a few more things from Stream Chat React so we can say import and that's going to be avatar for images and also use Chat Context and this is coming from Stream Dash Chat React Now that we have these things, let's actually use that context.

So right inside of here we can say const the things we need to get are going to be the channel and also the client that is coming from use chat context and we call it as a hook I'm going to rename the channel right here to say Active Channel because we're already getting a channel at the top.

With that said, let's create a block of Jsx which is going to be called Channel Preview So right here.

Channel Preview As we've done before, it's going to be a functional component just to simplify the life for us.

Later on and inside of here it's only going to be a simple paragraph tag with a class name which is going To be equal to channel Dash preview, underscore, underscore item and there we can say hash or pound sign and we can specify the name of the channel.

We can get to the channel name by saying Channel.data.name I'm going to add a question mark before the dot for the data and the name to make sure that we have the channel before we want to access something else or maybe the channel doesn't have a name.

In that case, we can use or and then say Channel Questionmark.data Questionmark.id This is a preview for the channel with multiple users, but now let's create a preview for direct messages.

We can do that by saying const direct preview is going to be equal to and then we instantly return it and there we're going to have.

Const members is equal to channel dot state dot members but unfortunately the data that we get back is not going to be an array.

While you might think we're gonna get an array with different objects like this, what actually happens is we get back an object like this and then that object has the Ids one, two, three and then there's the user object.

So it's going to look like this because each user has a specific Id and then based on that, we're going to show their data.

So what we need to do is we need to turn an object with again objects as keys and values to simply an array of objects that we can map through.

So let's remove this and this and let's use the built in javascript object dot values that's going to give us the values of all the items in that specific members object.

Once we get that, we also want to filter through that so we can call the filter method.

Filter accepts a callback function and in this case we want to filter through the members.

So in here we get each member, but to get the data about that member, we have to destructure it and then specify the user.

So this is how we're accessing each specific user in that object.

Then we want to check if the user dot id is not equal to client dot, user uppercase Id.

make sure that you have the Id all uppercased and close the parentheses properly.

So what we're doing here is we're mapping over all the users and we're keeping all the ones where the Id is not equal to the client Id, which is our.

So we're basically throwing ourselves outside of that chat so we can get the actual users we're talking to.

I've noticed this is not going to be an instant return, so I can just switch this to curly braces and in that case, we have to remove one parentheses.

Great! Now we have the members, but they're not including ourself So right inside of here, let's return a block of Jsx We can say div There, we're to have a class name which is going to be equal to channel dash, preview, underscore, underscore item, and then space single.

Inside of there, we're going to specify our avatar avatar is just the user's image.

So inside of there we can pass the image property which is going to be equal to members 0 and then question mark dot user, dot image like this.

Finally, we can also pass the user's name which is going to be members zero dot, user, and then dot full name.

Make sure to add question marks before all of these because we always need to know that the user actually exists.

Finally, we can specify the size which can be equal to a number of 24. Finally, below this avatar, we can also have a P tag and then in here we can list our member's name.

We already have that, so I'm going to copy the name and just put it here.

Now we have the Channel preview and the direct preview.

Let's actually use these components inside of our team Channel Preview.

So this Div is going to have a different class name depending on if the current chat is selected or not.

So we can say class name is equal to.

we're going to put it as a dynamic block In here we can say channel question mark dot Id and if it's triple equal to active channel question mark dot Id.

So if they are the same, our class name is going to be Channel Dash Preview Underscore Underscore Wrapper Underscore Underscore selected else it's simply going to be Channel Dash Preview and then Underscore underscore wrapper it's not selected Of course this also has to be a string and with that, we've entered our class name.

So still inside of our div, we're gonna add an onclick property on our click.

We're gonna of course select the actual channel, but for now, we can simply console log the channel name so we can say channel right here.

Great and then of course inside of this div dependent on the type.

So we have to say if type is equal to team.

In that case, we're going to render the channel preview and then if it's not, we're going to render the direct preview great.

This is it for our component for now.

Of course, I don't think any chats will be showing because we don't yet have the users.

So soon enough, it might be a good time to actually start implementing the logic for creating the authentication, getting our users in there, and displaying the data.

So for now, let's go back to our channel list container.

Considering that we don't currently have any chats, unfortunately, the preview is going to be empty below this channel list.

We need to create one more exactly the same channel list below the channel list for group messages.

We also need to have a channel list for direct messages, so simply select it and then duplicate it below.

We're going to have just a few small differences, for example, in the list, we're going to render the team channel list, but the thing we're going to pass over is going to be messaging.

so that's the type of the actual team channel list, and you can simply paste that here as well.

So now, once we actually get everything to work, you should be able to see two different channel lists, one for the group messages and one for the private ones.

Right now, we still have an error and that makes sense because we are not currently logged in.

we don't exist in database and there aren't any channels or direct messages, so now might be a good time to implement authentication and the entire logic that comes with it.

We have to create a node.js server, create endpoints for the sign up in the login, and then finally send the data from the frontend to the backend to create a user in the database.

So let's go ahead and first create the frontend layout for our authentication.

To do that, we can close all the current files, collapse everything, go inside of the client source, and then finally app.jsx Instead of here, we're going to import Auth.

Auth is going to be a new component where our login and registration form are going to be in.

So when do we want to render that Auth? Well, we're going to have a variable which is going to be something like Auth token and this odd token is going to be available only if we've actually logged in.

So for now, we don't have it.

It's going to be false and based on that variable, we'll show or hide the form so we can say if there is no Auth token.

In that case, we want to render or return the Auth component.

so we're gonna hide everything we've done so far.

If we're still not logged in.

now that we have this, let's actually go to our components, create a new file called Auth.jsx and let's not forget to export it from here.

That's going to be off Great inside of that off it's going to be similar situation.

As with most components, we're going to use the Rafce alongside React.

We're also going to need use state and we also need to import a few other things in this component.

We're going to use cookies so we can say import cookies from and that's going to be universal dash cookie.

Then we're also going to use Axios so we can say import Axios from Axios and I've just remembered that we haven't installed Axios so we can go under view that's going to be terminal and we can stop the current server from running by pressing Ctrl C yes and then type Npm.

Install Axios Great! While that is installing, let's import sign in image from dot slash Assets Forward slash Signup dot Jpeg Great! This is installed and we can simply run Npm, start and close the terminal again.

Now let's start creating the layout for our authentication.

Our first Div is going to have a class name equal to Auth Underscore, Underscore Form Dash Container.

Then below that we're going to have one more Div and that Div is going to have a class name equal to Auth Underscore Underscore Form Dash Container Underscore Fields We're going to have one more container inside of that and this Div is going to have a class name equal to Auth Underscore Underscore Form Dash Container Underscore Fields Dash Content I know these class names are getting long, but this is how you use the Bim methodology.

Now inside of there, we're gonna have a P tag and this P tag is simply going to say sign up or sign in So we need to have a variable to know.

Are we on the sign in form or on the sign up form.

So let's create that variable that's going to be a state so we can say use state and select it right there.

So we are going to name it is sign Up.

Are we on the signup form or are we not.

The initial state of the sign up is going to be set to false because we want to get to the sign in first and then in here.

We can say if is sign up.

In that case, show sign up.

Otherwise, show sign in.

Let's save it and take a look in the browser.

As you can see we have this nice blue screen where it says sign in Now let's keep in mind that we'll have to add a lot of inputs, buttons and headings to this form and we want to see the changes live as we code them.

For that reason, I'm going to put my browser side by side with the editor.

So right now while we code something, we can see the changes live great Just below the paragraph, we're going to have a form.

That form is going to have the unsubmit property which is going to be empty for now and then Inside of that form, We're going to have a lot of inputs and labels.

Some inputs will be available only on the sign up so we can make that check like this.

If is sign up, then show this.

This is the shorthand method for the ternary operator.

You use the ternary if you have two things that you want to show but you simply say is sign up and then end end.

If you only need to show one thing based on this condition, So what do we want to show if it is on? Sign up.

Well, we want to show a Div and that div is going to have a class name equal to Auth underscore, underscore form, Dash Container Underscore Fields Dash Content underscore Input This is the longest class name so far, but it's fine.

We got it done.

So inside of that input, we're going to have a label.

That label is going to have the Html4 property and is going to be equal to full name inside of there.

We can simply say full name of course below the label.

We have to have the input.

So I'm going to say input and let's add a few properties.

First, the name is going to be set to full name, then the type is going to be equal to text, then the placeholder can simply say full name and finally we need the on change property on change.

We're going to call a specific function called handle Change and this handle change is going to handle the change for all of the inputs that we have.

Also, let's make it required great.

So this is it.

Let's save it.

Of course we have an error.

We cannot have an empty on submit.

So for now I'm going to put a callback function inside of there.

And of course we also have to declare the handle change so we can see const handle change is equal to and for now we're going to leave it as a blank callback function.

Okay, we cannot yet see this because we are on the sign in form and not sign up.

So let's manually switch this to true and there we go.

Full Name with the full name input.

Of course we don't want to create all of the fields by hand, so let's simply copy this div and paste it below.

The label is going to say username this time and we can say Html4 Username Now of course the name of the input is going to be username, the type is going to be text and then in here we can just say username and that's about it.

We have the input for the username as you can see right here.

Now you might be wondering why is this not inside of the Is signup block And that is because, well, we need the username both When we're signing up for the first time and every time that we sign in, the user needs to enter the username now below the username, we're going to have one more field and this one is going to be inside of the Is signup block.

So I'm going to copy this entire block and simply paste it below.

There we go.

This one is going to be a phone number so we can say phone number here.

Html4 phone number, name, phone number, type, text, placeholder is going to be phone number as well and we're done with one more input field below that one.

We're going to copy everything and this one is going to be avatar url.

This also needs to be shown only on the sign up because we need to choose our image only once.

So that's avatar url like this.

Make sure the name contains the url all uppercased and then in here as a placeholder.

We can also say avatar url Great! Below that we're going to have our password this time.

We won't show it only on the sign up so I'm going to copy this div and paste it right here.

We can rename this and this to password Html4 Password name is also going to be password and the type is going to be of course password.

That's it.

Our password field showed up.

Now we want to have just one more field but this is going to be when we want to repeat the password.

So I'm gonna paste this entire part right there.

We need to copy the Is signup block because we only want to show the confirm password on the account creation Like this.

I know the indentation is not perfect, but let's try to get it done and this here is going to be Confirm Password.

I can put that here as well, Confirm Password and the name in the Html4 for that are going to be Confirm Password and again make sure that the name in all of these inputs is correct because the way we'll be managing data requires us to have a specific name right here.

That's great.

We have one more field which is Confirm Password.

Finally below that we're going to have one more div and that's going to be outside of the form.

So I'm going to put it outside and finally indent it properly.

Now I can even make the text a bit bigger and this div is going to have a class name equal to Auth Underscore Underscore Form Dash Container Underscore Fields dash Account So in here we can simply add a paragraph tag.

In this paragraph we want to show a different message depending on if user is sign up or if not so we can say if is sign up.

In that case we can display a message something like this is sign up and that's going to be already have an account question mark but if it's not then we can say don't have an account question mark We need to be able to switch between the modes and then we're going to have a span element inside of that p element and it's going to have the on click property which is going to say switch mode in there we can again look at the is signup variable and if we are on the sign up then we can show sign in.

Otherwise we can show sign up.

Let's save it and take a look.

Of course our switch mode is not defined so let's define the switch mode.

That's going to be fairly simple at the top.

Let's define the switch Mode function by saying const switch mode is equal to a function and then in there we can set is sign up to be not is sign up.

But the better way to do that is to provide a callback function where we get the previous value of a state field.

So previous is sign up and we simply want to return a negation of that so that's going to be not.

Previous is sign Up.

This is the correct way to do it in React when you want to change the state depending on the previous state.

There we go.

we have the sign up form and the entire thing.

Now if I click sign in, it switches to the sign in which is a lot simpler.

Finally, we also want to display an image next to our form.

So we are going to go above the Div that's the last one so above here and we want to create one more div inside of here.

That div is going to have a class name equal to Auth, underscore, underscore form, dash, container, underscore image, and then in there we can simply display that image that's going to be Img and then source is going to be equal to sign in image which we declared above.

We can also have the alternative tag which is going to say sign in Great! As you can see, it doesn't look that good on smaller devices, but if we actually switch to mobile, you can see that it gets pushed to the top and it seems like a banner.

But then if we go to the full screen you can see it looks great right here as well.

So the actual layout for our login is now done.

Now we have to handle the states of these fields and then send them over to the backend which is going to create an account or log in The user.

Then our user is going to be logged in onto the dashboard we've created previously and we'll be able to show all of his channel previews, direct messages, and everything else.

First, let's handle the data from all the inputs.

That's what the handle change function is for.

But of course we first have to create a state field.

Let's create a new state field called form.

So we're going to have form and set form which is going to be equal to use state And there we want to show something.

At the start, we want to have an initial state.

so at the top we can define that initial state as an object and that object is going to have a few properties.

It's going to have a full name which is going to be equal to an empty string.

We can also add the username equal to an empty string, there's a password which is equal to an empty string, and all of the fields we've had.

We have to reset them to an empty string.

so it's going to be a phone number and then finally the avatar url.

These six fields form our initial state and we can put them right here.

So now we have our form and set form and finally let's add our handle change.

So what do we want to do on the change? Well, we get an event with the text of the input we're changing and then we want to call the set form.

So remember, a form is not just a single text field, it is actually an object.

So we have to put an object there and we have to spread all of the other items from the form.

So we spread all the other inputs because we're only changing one and we want to keep all the other ones.

But then how do we change a specific one? Well, we're gonna get E Dot Target dot name.

That's the name of the input we're changing and then the value for that same input is under the event.target.value And why are we using square brackets right there? Because this here is a syntax error.

so you have to wrap the name of this specific object key in the square brackets and then set that equal to E.target.value That's going to update our state field and we can even take a look at that by simply doing a console log which is going to say form.

So let's check it out.

There's my form and I'll try typing something Smith.

There we go.

As you can see, it's keeping track of everything that we write.

The username can look like this and as you can see now, it kept the full name but it keeps adding to the username and it's always going to be one letter late.

But don't worry about that because our user still has to click the actual sign in button.

Now that I've mentioned that, I'm noticing that we are actually missing our sign in button, So let's add it right away.

That button is going to be right here as the last thing in our form.

so still inside of our form, we're going to have a button.

More specifically, it's going to be a Div with a class name which is going to be equal to Auth Underscore underscore form, dash, Container Underscore Fields Dash Content Underscore Button a long one And then inside of that div, we're gonna have a button.

That button is going to check if we're on the sign up or on the sign in.

If we're on the sign up, we're simply going to say sign up Else we're going to say sign in.

Let's save it.

Okay, now we have the button and that button is going to trigger the actual submit.

So if you scroll up, you'll notice that right here.

We have our on submit and we have to create a function for that.

So let's create a handle submit function.

We can add it right here.

Const: Handle Submit.

It's going to accept the event and in here we have to handle the logic of logging in or registering.

Usually when you submit a form, you need to add e dot prevent default because it's going to reload the page and in react We don't want that.

Okay, now we have it.

Let's also console lock the form to see if we're getting the right thing passed to the back end.

We can remove the console from the handle change.

Let's save it and take a look.

Okay, let's enter our name.

Let's do Dr.

Smith again.

Dr.

Smith as the username one two three one two three one two three in here we can enter his avatar image.

I just went on Google and I copied the image address.

so we have a doctor image address here and then finally let's enter and confirm the password.

I'm going to click, sign up and look at that.

Here is our data object.

This is exactly what we want to pass over to the back end so that we can create a new stream account.

Let's do that right away.

Of course, to be able to make requests from the front to the back end, we have to create the backend part.

so let's close all the files, collapse it, and go inside of our server directory.

Inside of there, we can create a new index.js file.

This is going to be the starting point for our entire server.

We can also open the terminal by going to view terminal and we can split the terminal in half by clicking this button.

Now this one is running the front end and with this one, we can Cd into the server part.

Let's clear the console and we're going to run Mpm Init Dash Y.

This is going to initialize Amt package.json There we go with that.

We can now install all the necessary dependencies and add corresponding scripts.

So let's first start by installing all the necessary dependencies to do that.

We can run Npm install, make sure that you're in the server part of our project and we're going to need bcrypt.

We're going to use that for hashing passwords also crypto to create a random cryptographic string.

Then we're going to need dot env for environmental variables also express.

Also get stream and stream dash chat.

We are also going to use Nodemon and finally Twilio for sending live Sms messages.

So let's press enter and we're going to wait for this to be installed.

Now that our packages have installed, we can add some new scripts.

So I'm going to delete this test script and I'm going to add a start script.

make sure that everything is in double quoted strings because we are working with Json and then right here we can say Node Index.js This is a command to start our server below that I'm going to add a Dev command which is going to run Nodemon Index.js Nodemon is a package that reloads your application whenever you change the code, so we need that for development.

So as you can see now we have the scripts.

We also have all the dependencies and let's create the basic Express Node.js Server.

So inside of Index.js we can say const Express is equal to require and then express.

We also need course so we can say const course is equal to require and then that's going to be course that's used for cross origin requests and I just remembered that we didn't install that so we can say Mpm install and then simply paste course.

Okay, now that we have Express here, let's create the instance of that express application by saying const app is equal to Express and then we call it.

We also need to specify the port for our backend so we can say port is equal to process.env.port or 5000. Also, we're going to use a lot of environment variables so we can say require and then dot Env and then dot config.

This is going to allow us to call the environment variables right inside of our node application.

Now let's set up our middleware by saying App.use inside of here.

We can use that course if we call it as a function that's going to allow us to make cross-origin requests.

We need to set one more middleware which is going to be express.json and you call it as a function.

This will allow us to pass Json payloads from the front end to the backend and finally app.use and inside of here we're going to say express dot url encoded.

This is a built in middleware function in express so it's going to be url encoded.

Like so great.

Finally, we are ready to create our first route and that's going to be app.get and it's just going to be a root route So we can say just forward slash create a callback function.

That callback function is going to receive request and response as parameters.

We can use the res.send method to simply respond with something like hello World just so we know that our backend server is running.

Of course, for our server to be running, we need to run it on a specific port and we need to listen for it.

So let's say app.listen and that's going to be on port port.

We get a callback function and there we can simply say console.log and say something like server running on port and then we can say port right there.

Of course.

For this to work, we have to use backticks so I'm going to put them right here and here and we have to close the last parentheses.

There we go.

This is a minimal instance of an express application, so let's run it.

I'm going to run it in the development mode by saying Npm run Dev Nodemon Started their application.

on Localhost 5000. So if you open up Localhost 5000 in the browser, you should be able to see Hello World.

That means that we successfully created and ran our server.

Now let's add routes for our sign in and register.

We can do that by requiring routes at the top.

Const: Aud routes is equal to require and then that's going to be dot slash routes and then forward slash Auth.js Of course we haven't yet created that.

So let's go to our server and let's create a folder called Routes Inside of there, we can create a new file called Auth.js There, we need to require Express So we can say const Express is equal to Require Express and we need to get a router from that Express by saying const router is equal to Express.router and we call it Finally, We're going to create two different routes: Router.post Both of these routes are going to be post routes because we have to send the data from the front end to the back end and only with the post routes can you send a payload.

The first one is going to be to forward slash sign up and the second one is going to be to the forward slash login.

Of course we want to have a function that's going to happen on each one of these routes.

So we're going to create controllers inside of the server.

I'm going to create a new folder called Controllers and inside of there, I'm going to create the Auth Controllers.

So Auth.js Now inside of there we can create the actual login function by saying Cons: Login is equal to a function like this and also we can create the sign up function like this.

Of course, these functions don't do anything yet, but we're just creating them so that we can export them right here.

and with modules, we do.

Module Dot Exports is equal to an object and there we have the sign up and also the login.

So now we're exporting the functionalities which are going to happen once we go to a specific route.

So inside of here, we actually have to import them And we can do that by saying const, sign Up and Login we're getting that from.

Which means equal to require dot dot slash controllers slash odd dot Js And what do we do on the sign up post, We call the sign up on the login post, We call the login and we need to export our router, which we can do by saying module.exports is equal to router.

Now we can use this router inside of our index.js which means that these routes are going to be added to our whole server.

We can do that by saying app.use and then we can specify the start of the url which is going to be forward slash auth.

And what do we show on the forward slash auth Well, we show the Auth.

routes which we imported from the routes folder.

That part is now done and now the only thing we have to do is actually implement the logic of receiving the data from the front end and finally creating or logging in the user.

A reasonable first step would be to create the sign up first because we have to have the users to be able to log them in.

So let's try with the signup, we're going to have a try and catch block right there.

If something goes right, we're going to be inside of here.

If something goes wrong, well we're inside of the catch.

If we're there, we can simply run console.log error and also res dot status 500 dot json and then we're simply going to send back the message which is going to be the error.

You might be wondering where is this rest coming from? Well, every single controller is going to have the rec and the rest functions.

Our rack is going to contain the information what we're sending from the front end.

Now I'm going to copy this part to the login as well because that part is the same.

and let's start implementing the sign up for the sign up.

What things do we need to get from our request? that body, or more specifically from the front end? Well, we can destructure it because we are getting everything from direct.body So what do we need? Well, we need? a full name to save it to the database, also, the username, the password, and finally the phone number.

Now that we have that information, let's create a random user Id for each new user.

We can do that by saying const user Id is equal to crypto.

That's going to be a package that we need to import at the top.

so just at the top above the sign up, let's require the crypto package or let's also require all the packages that we're going to use in this file.

So that's going to be const connect that's coming from or more specifically, require get stream.

Then Also, const, bcrypt is equal to require and that's going to be bcrypt.

We also need an instance of a stream chat.

so we can say const stream chat is equal to require stream dash chat.

And finally, Cons: Crypto is equal to require crypto.

That's it.

Now we have everything that we need.

Let's scroll down and let's implement the user id.

So to create a random crypto string, we can say crypto dot, random bytes and let's do something like 16 and create a hexadecimal string out of it.

This is going to create a random sequence of 16 hexadecimal digits.

Now let's make a connection to stream.

We can say const server client is equal to connect and now we have to use that connect from the get stream to connect to the server.

but we need to pass a few things.

We need to pass the api key.

So let's specify it here: Api Underscore Key Also, Api Underscore Secret and finally App Underscore Id.

All of these things should be secret and you shouldn't share them with anyone.

That's why we're gonna use environment variables.

So just at the top, let's say Const Api Underscore key is equal to process Dot Env that stream underscore Api Underscore Key I'm gonna duplicate this two times.

The second thing is going to be Api Underscore secret and in here we can say Stream Api Secret.

Then we're going to have the App Underscore Id and that's going to be Stream App Underscore Id.

So Stream Underscore App Underscore Id Great! Now where do we find these values? Well, you can find them in your stream dashboard.

Let me show you right here on your stream dashboard.

You have your profile, you go to chats, and then finally you go to Overview.

There at the top, you'll be able to find your app Id.

So that's the first thing that you can copy.

Now we can create a new file inside of our server called Dot Env and there we can add our app Id.

So I'm going to copy the name stream App Id and paste it here and add the equal sign in between.

So Stream App Id like this.

Also, we can copy those, paste them and let's go back to the dashboard to find the values for the secret and for the key.

Now, if you scroll a bit down, you should be able to see app access Keys Here is a key.

let's copy it, paste it right here.

And finally a secret.

I'm going to copy it and paste it right here.

Now we have all of the necessary environment variables.

Let's go back to our controllers and now these values api, key secret, and Id are going to be populated straight from our environment variables.

Therefore, we can use them right here to connect to our server client.

We are going to use that server client to create a new user token.

So let's create a password first.

Const: and that's going to be hashed.

Password is going to be equal to a weight bcrypt and then we call the dot hash method on the bcrypt and we pass in the password.

And finally we can pass 10 as salt.

Basically, how much is it going to encrypt it? This number specifies the level of encryption.

Great! I've noticed that I didn't specify my function as Async, so let's add it as Async because we're using a weight in here and this line is turning our plain text password to the hashed password.

Finally, let's create a token for our user by saying Cons: token is equal to server client dot, create user token and then in there we can pass the user Id.

Now we have everything we need.

We have a phone number, username, full name token, everything ready to create a user.

So let's return that data to the front end, rest that status is equal to 200 dot json, and then an object.

We want to pass the token, full name, username, user id, hashed password, and finally we also want to pass the phone number.

We could get these values straight from the front end, but let's get them from the back end as it's more secure that way to be sure that this is the actual user we're creating.

And while we're here, let's also create our login function.

It's also going to be an Async function.

We also want to get some data from the front end const, and in this case we just want to get the username and the password that part is coming from.

Wreck that body and Rig.

That body is getting populated as we pass data from the front end from our form which we created previously to the back end.

We also want to connect to the client so we can use this server client connect.

It's going to be the same thing.

I'm going to paste it here and we also want to create a new instance of a stream chat.

We can say const client is equal to stream chat, dot, get instance, and then in there we pass the api underscore key and api underscore secret.

We need to use that because we want to query all the users from the database that match this specific username So we can say const They structure it to get the users and then say equal to await Client dot query users and then only the users that match the name which is equal to username.

So one more time this time we're not creating the user, we are taking the username and we want to query all the users from the database to see if anyone matches if there are no users so if no users.length then in that case we can return rest.status Let's do 400 dot json and the message is going to be something like user not found If we go over this point, that means that our user does exist and we have to decrypt the password and see if it matches the one that the user created the account with.

So we can say cons Success is equal to await bcrypt.compair We pass in the password and we take the old user's password by saying users 0 dot hashed password Again, every user is going to have that hash password variable because remember when creating the user, we actually create the hashed version of his password.

We are not keeping it in plain text and that's why we gotta do it Now that we have that, we also want to create a new user token by saying Cons: Token is equal to server Client dot create user token and this time the token has to be created using the same existing Id So we can say user 0 dot Id.

We are no longer passing just a regular user id which we just created.

We want to pass that specific user's id and now that we have everything, we have the token if our action is successful.

So if this is success in that case, we want to finally send all the data back so we can say rest that status is equal to 200 and then dot Json.

And here pass the data we want to send.

We want to pass the token.

We also want to pass the full name which is going to be equal to users 0 dot full name Then we want to pass the user name.

Finally, we want to pass the user id by saying users 0 and then dot Id.

Now we have everything we need.

Finally, if we had a failure here, we can say rest.status That's going to be 500 dot json and we can simply return a message in an object which is going to say incorrect password like this.

That's it.

I know that this hasn't been easy.

We are creating users creating different user ids, hashing passwords, sending the data back to the front end, and then for the logged in users, we are querying that user from the database, again, decrypting that password, comparing it, and then finally creating the new token and sending it back.

It's definitely not easy, but now we have our back end done.

Now we can close all of these files and then go back to the client side more specifically, in components Auth, and then from here into handle Submit: Remember this form data.

We want to pass that form data back to our back end.

Let's do that right away.

Okay, instead of console logging the form, let's actually get the data out of it.

We can say const and then destructure some data from the form.

In this case, we are going to need the full name, username, password, phone number, and then finally the avatar url.

And all of this is coming from not E Target, it's coming from form.

Then we need to specify the url we'll be making a request to so we can say conturl is equal to and that's going to be Http Colon, Forward slash forward slash localhost Collin 5000.

That's it.

This is our url, but don't forget it's going to be to forward slash Auth.

Now that we have the data and we know our url, let's make an Axios call.

I'm going to turn this function into an Async function so that we can use Async away.

And let's use Axios to make that request.

We can say const, that's going to be data and that is coming from await Axios.post we post to a specific url.

so I'm going to say url but it's not it.

We have the forward slash.

odd, but then it has to be either sign up or log in and how are we going to know which one is which? Well, we can say forward slash and then inside of here we can see are we on the sign up.

So if it is, sign up.

In that case, we are going to simply show sign up.

But if it's not, sign up, we are going to go to sign in so we can have this logical block right inside of our string right here.

And finally, the second thing that we have to pass into this function is going to be the object.

with all the data.

We can pass the username also the password, full name, and finally phone number, and the avatar url.

Great! There are a lot of things we're passing, but we should be fine from that.

We are getting the data.

That's the data we're passing back from the front end.

Now that we're passing the right url and we're passing all the necessary data, we'll also be getting something back from that data.

So let's immediately destructure some things out of it.

We are going to the structure, the token, also, the user id, and finally the hashed password.

Great! Now let's use those values to add them to the browser cookies.

So let's create an instance of our cookies at the top.

I'm going to say const cookies is equal to new and then we call cookies.

Great, right? Here We can use those cookies by saying cookies dot set and then for example, let's first set the token right here.

I'm gonna say token and then pass the actual token value.

Now I'm going to repeat this three more times.

and the second time instead of the token, it's going to be user name.

For the third time it's going to be the full name.

We want to store all of this data inside of our cookies and then finally it's going to be user Id.

But if we're creating the account, so if is, sign up we have some more things we might want to set.

So I'm going to copy these and if it is, sign up.

We also want to set the phone number.

So right here.

Phone Number: Also the avatar url.

Make sure that all letters are uppercased and finally hashed Password: In this case, we are storing everything inside of the cookies.

We might not need everything on our front end, but it's just good to know that all the data we're getting from the back end we now have it.

We have the avatar url, the phone number and we'll be able to use it all across our application.

Finally, once we set the cookies, we want to reload our browser.

We can do that by saying window, dot, location, dot reload and we call that as a function.

With that, we are completely done with our odd file.

So one more time to repeat, we are going to fill in all the inputs.

Then we are going to go into the handle submit function, get all the data from the form, get the url, make the request to our backend.

More specifically, we're going to make a request to a different url each time depending on if we're logging in or signing up, and we're going to pass all the form data.

Then we're going to get some data back from the backend and we're going to store everything into cookies.

Then finally, we're going to reload our application.

Why are we doing the reload? Well, if we do the location.reload we're going to reload the application and this time our Auth token should be filled.

That means that we are not going to hit Auth again.

We are going to go to our chat as a logged in user because now we're going to have our odd token.

Okay, but right now we have this odd token set to be false.

How can we actually get the data? Well, we can do that using the cookies.

We can say const cookies is equal to new cookies, same thing we did before and now instead of setting the values, we are going to get them.

Let's first get the odd token.

I'm going to pull this up below the api key and we can simply do cookies, dot, get, and then in here.

it's going to be token.

Now we can see if we have that Auth token by doing if odd token.

If we do have the Auth token, we want to create a user so we can say dot Connect user.

If the user hasn't been created yet, it's going to create it.

So Client dot, Connect user.

This thing accepts an object.

so let's expand it and we have to pass everything that we have right here in the cookies.

So I'm going to simply copy these values and also these values.

Now I'm going to go back and simply paste them.

As you can see, we have all of these cookies.

Of course this is not in the right format so what you can do is click here.

Then you can move across by holding Ctrl and using arrow right and arrow left.

By doing that, we can now delete or reset this set to simply get.

Also, we are not setting anything so we can delete these values by simply moving to the end of each line and then holding control and pressing backspace.

As you can see, now, we're simply getting all of the values, but we're not done yet.

Of course we're in an object, so we have to have the key go at the end of the string, hold Ctrl and shift and press arrow left.

That's going to allow you to copy each word Now press Ctrl C and then a few more times Ctrl left arrow go to the start of the line and press Ctrl V and finally a colon.

Once you do it one more time, go to the end of the line and turn all semicolons to simply columns.

And just like that, we've used some shortcut magic to format all of our data from setting the cookies to getting the cookies and using them for the connect user call.

Now if this was a bit too much for you, or if you followed along, but you would like to learn more cool shortcuts, let me know in the comments down below to create a whole shortcuts video.

If this was too hard for you to follow along, definitely make sure that you have everything the same as we have right now.

You need to have the token, username, full name, and all these details being fetched from the cookies.

We have to make just a few changes.

The user Id cannot be user id.

it simply has to be Id.

That's how it is in the client.connect user, then instead of the username.

This thing here is just going to be name.

After that, we have full name.

After that, instead of the avatar url, we're going to call this simply Image.

Then we're going to have the hashed password, and finally, the phone number.

We won't need the token here because we're already getting it at the top so you can remove that line.

Now that we're done with this, make sure that you have everything the same just in case so that we don't have any errors moving forward.

Finally, this connect user function accepts a second parameter which is odd token that same token we had right here.

That's it.

This is going to connect our user and we'll be able to get all of his messages.

Now let's see if our If statement here makes sense.

So if there is no odd token, then return Auth.

But if there is odd token, then simply show this and that's exactly what we want to see.

So let's try creating a user and then logging in as that user.

Before we go ahead and sign up, let's quickly open up the stream chat overview right here.

You can go to chat and then explorer under users.

You should be able to see just yourself, your own user and then under channels.

No results at the moment.

So if we successfully did everything once we sign up, we should see a new user created right here.

So let's go to our medical pager before I click sign up.

I'm going to open the console and let's click.

sign up.

There we go, we have an error which is completely normal.

We did a lot of coding, but we haven't tested it.

so now is the time to finally do so.

We have a 500, Let's look at it, 500 on the sign up and we have a message.

This method can only be used on server side using your Api secret use client and then stream Connect.

So looks like we are using something that shouldn't be used on the backend.

Let's check it out in more detail.

Looking at the code and looking at the stream documentation.

I've noticed that right here alongside stream chat and just requiring stream chat, we also have to create an instance out of it.

So right there we have to say stream Chat.

I'm assuming that the values of these environment variables are undefined.

so let's go to our index and then let's take this require.env.config And let's just put it right here above where we need those values.

I'm going to save it, go back, and one more time I'm going to click sign up.

There we go.

We didn't have the values for the environment variables, so let me quickly explain what happened.

We were trying to connect to this specific thing and it was saying you cannot connect These values are not filled in so I assumed that the environment variables from the Env weren't filling in.

and that means that we need to require the Envconfig just prior to using the environment variables.

So just by adding this line, we fixed the issue.

But also, it's good that we came across this issue because I've noticed that we were missing this dot stream chat here, so definitely make sure to include that part.

With that said, we are actually logged in.

As you can see right there Channel Container We have our channels and direct messages and you have no channels currently of course right now we don't even have the button to create those channels, but if there were any, they would show here.

What we could do is now go to Stream Chat overview and see if that user has been created.

So let's go to Explorer users and look at that.

This is our user id and if you click it you can see right here.

you can see the phone number, the hashed password.

This is what the hash looks like so we don't want to share a plain text password.

And then finally here is the name and the full name and the image.

Everything is here.

The user has been created, which means that our sign up works.

Now let's try to log out and let's try to see if the sign in works, but you might have a question.

how do we actually log out? Well, we have a button here, but right now it's not doing anything so let's make it do something to do that.

I'm first going to close all the files and collapse the files and folders, go to client source components and then that's going to be channel list container.

More specifically, we should be looking at the sidebar.

so I'm going to go to the top and there is our logout button.

What we have to do is just below: create a new function.

Const logout is equal to an arrow function.

And basically we want to clear the cookies and also we want to reload the window.

So how do we clear the cookies? Well, let's go to the app.jsx I'm again going to copy all of these including the Auth token.

I'll go back to the channel list container and paste them all here.

Now we just have to do some formatting.

Remove these previously object keys.

We just have the cookies dot get.

But now we have to switch all of these from cookies.get To Cookies.remove These have to be semi-colons So let's do it like this.

And as you can see, our cookies are not defined.

So at the top, let's just say const cookies is equal to new cookies.

Now below.

We are removing all the cookies and finally we have to call the window location dot reload to reload the page to get us back to the authentication page.

Finally, this logout is not being used right now.

So let's pass it as a prop to our sidebar and now on Sidebar.

Let's retrieve it from Props right here.

and let's actually use it once somebody clicks on this button.

So I'm going to give this div an on click listener and simply call the logout function once somebody clicks on it before actually testing it out.

I've actually made a typo.

This here is remove and not removes.

Now if we save it, let's finally check it out.

We are back on our medical pager and let's click the log out button.

There we go.

We were logged out and we're back on the sign up screen.

Let's go to the sign in and let's try to sign in as Dr.

Smith one more time and the sign in worked perfectly.

We are in great notice how we no longer have the error here.

It's just you have no channels because that's it.

We don't really have them.

So now let's create the rest of the screen.

the entire right part, which is the channel container where the messages are going to be the input for sending messages, gifs, and everything else.

Let's start with the channel container if you remember correctly inside of the app.jsx we have the channel list container and finally the channel Container.

Now is the time that we start working on that second piece of the puzzle.

So let's go inside of the channel container and let's start implementing the logic and the Jsx.

First of all, we're going to import a few things from stream.

These things are going to be channel and also use chat context and this is coming from stream Dash Chat Dash React great.

These are all the external imports, but we're also going to have quite a few internal imports meaning components that we are yet to create.

These components are channel inner.

Also, create channel.

We're gonna have the edit channel and finally the Theme message.

These things are coming from Dot Slash Again, that's our components folder.

so let's quickly create the layout for these four components.

First, starting with the Channel Inner, I'm going to create a new component Channel Inner Dot Jsx Again Inside of there, let's run rafce and I'm simply going to put Channel Inner inside of it.

Then moving on to the second thing, which is the Create Channel component that's going to be Create Channel Dot Jsx Again, I'm going to copy what we had in the Channel Inner and simply change the naming to Create Channel.

Moving on to the third thing, which is the Edit Channel thing.

So right there.

New file.

Edit Channel Dot Jsx Again, I'm going to copy what we had in the Create and paste it here, rename this to Edit Channel, and then going back one more time for our Team message.

I'm going to create a new file called Team Message.jsx and final time, I'm going to copy it, go to the message and rename everything to Team Message And don't forget we have to go to the index, Duplicate this four times, and finally, we have to add imports for all of these components.

So these components are going to be the ones we just created, So that's going to be Channel Inner right here.

Create Channel as well.

Finally, Edit Channel and the Theme message.

With that, we've created all of the imports and I think that's going to be it for the components.

We might have just one or two more, but we are basically done.

So let's see how we can use those components to create a layout in our channel container.

First things first, we need to get the information about a specific channel.

We can say const that's going to be channel is equal to use chat context that's going to give us the information about the current specific channel.

Then we need to know are we currently creating that channel, Then we have to show a specific message or a dashboard for creating that channel.

So we have to have a variable called is creating and if we are creating we want to return a specific Jsx block, then we're also going to have one more state which is is editing So I'm going to copy this, paste it here, and say is editing These are some states that we always need to be aware of.

We have to know this information inside of the channel container, but we also have to know it inside of the channel list container.

For that reason, we're going to declare these state fields right inside of our app and that will be the next step.

So right here, let's create a state field called Const: Create Type Set, Create Type and that's going to be equal to use state and we're going to leave it as an empty string.

We also have to import use state at the top.

Okay, and I'm going to duplicate this two more times.

The second thing is is creating.

So is the user currently creating a new chat room and also Set is creating and at the start it's going to be set to false.

Then finally we have is editing and that's going to be set.

Is editing also set to false? Now that we have these variables, we can pass them as props to our components.

So we can say is creating is equal to is creating and then set is creating is equal to set is creating.

We also want to pass Set is editing is equal to set, is editing and finally is editing itself is equal to is editing.

You might already notice that this is not the best way to pass props.

A better approach in this case would be to use the context api.

But for now, let's keep it like this.

I'm going to copy this and paste it right here so that we are also passing the props to our channel container.

Our channel container is also going to need.

The create type is equal to create type and I've just noticed we won't need this is editing.

Rather, we will need set.

Create Type is equal to Set Create type like this and I just noticed I have a typo right here.

Okay, now we're good.

Now we're accepting all of these props.

We can even copy them and we're accepting them inside of the channel container so we can go back.

And now.

right here in the props, we can destructure them all right here.

Of course we have to separate them by commas.

so let me add some commas here and again.

I'm going to use some keyboard magic to simply put them all in one row.

There we go.

So now we simply accepted all of the props we're passing right inside of the channel container.

And now based on these variables we can show is creating window is editing window, or the channel container itself.

First let's start with is creating.

If the user is creating a new channel, we can create a Div.

That div is going to have a class name which is going to be equal to channel underscore, underscore container, and then inside of there we can simply render the create channel component.

It is going to be a self-closing tag and we can pass two things.

The create type is equal to create type and we can also pass.

Set is creating which is going to be equal to set is creating.

Now for the editing.

I'm simply going to copy this div and it's going to remain the same.

This is going to be channel container but instead of create channel we're going to have edit channel and instead of the create type which we don't need, we're gonna be passing.

Set is editing great, so that's it.

Right now, we have no way of seeing these components because we don't have buttons to initiate the creation process or the editing process.

So let's keep it going with all the possible states.

We have just one more state and that is going to be const empty state.

That happens when we just create a chat and we have no messages yet so we want to display something.

it's going to be an instant return.

We are going to return a Div with a class name equal to channel dash Empty Underscore Underscore container.

Now inside of that Div, we're going to have two paragraphs.

First, one is going to have a class name equal to channel dash, empty, Underscore Underscore First and in there we can say this is the beginning of your chat history and then I'm going to copy that.

The second one is going to be channel empty.

Second and there we can say something like send messages, attachments, links, emojis, and more.

So this is our empty state.

And finally, let's declare the channel container itself.

The Div is going to have the class name equal to channel container.

And there we're going to render the channel component.

Channel is not a self-closing tag.

We have something inside of there and that something is channel inner.

So this is the inner part of the chat application.

We have to pass a few props to our channel, so let's expand it.

The first prop is going to be empty state indicator.

That empty state indicator is going to be equal to empty state and then we can define how our message is going to look like so we can say message is equal to and that's going to be a callback function where we get message props and we also get the index.

Make sure to spell this correctly and what do we return? We return our special team message that's going to have a key equal to I and we're also going to spread the props right inside of it.

So dot dot, Message props.

Finally, we just have to pass one last prop to our channel Inner which is set is editing is equal to set is editing.

So just before we go to the browser to check it out, we are going to add one more thing inside of our app.jsx If you scroll to the top just next to our app.css we are going to add one more import line more specifically import stream dash chat, react and then we're going to take their index css for pre-built components.

This is going to help us to more quickly get a better looking chat application.

Now that we're done with that, let's go into our channel inner.

The channel inner is just a bit different from all the other components.

It has a lot of business logic and a lot of if statements just to check if something that we pass to the input is an attachment or a gif or a text.

For that reason, I don't want you to spend a lot of time on doing something that's not really educational and we're simply going to copy and paste it, so attach below.

You'll find the entire code for the channel inner as you can see right there.

It mostly has some overrides, setting up the states, using things from the channel, action, context, and then mainly using a lot of different stream chat components.

Let's see the Jsx part and this is about it.

We are setting up the window, the team channel header, message list, message input, and the threads.

These components are not the components that we create.

They are here for us right out of the box when using stream chat.

So let's save it and let's take a look in the browser.

There's currently nothing here, but if we go to Stream Chat Explorer which is right here and then under users find your new user, copy the Id.

Let's go under channels, create a new channel, and let's call it something like cardiology to keep it medical themed.

That's going to be a team channel type and let's click create.

Once it's created, let's go to members, add new channel member and paste that Id you copied.

Let's click, add and go back to medical pager.

If you reload the page, you should be able to see that.

Now we have the right portion of our screen.

Cardiology three users online.

This is the beginning of your chat history.

Send messages, attachments, links, and more.

Great! So let's try sending our first message.

Let's say hello World And there we go.

We can only see team message and for every message, that's the only thing we'll be able to see because we haven't yet coded out the most important part and that is the actual message.

If you click right there and more info, you'll notice that we also don't have the edit channel component, so that's something.

We'll have to code that together as well.

Now let's start with coding out the theme message.

Now let's remember where our theme message is.

It's going to be in the channel container.

If we scroll down, you'll notice that we have our custom team message here.

but I've just noticed that Stream Chat React already has a good looking team message and we can get to it by specifying message team.

That component is deprecated.

Feel free to find any other newer or rename component.

I really like the look of this one so we'll keep using it for this video.

We no longer need this theme message right here, so feel free to delete it from the components folder.

Now we can use this message theme.

If you scroll down and simply paste it right inside of here.

that's going to display all the messages that our users have sent and there we go.

take a look at that.

Dr.

Smith.

Here is the image.

Here is even the timestamp and here's a hello and a Hello World.

We can try testing some new things like tests and then an emoji and that is sent as well our messages are being sent.

We have the entire chat room here.

Dr.

Smith timestamps.

We can even add emotes to those messages.

As you can see right now, we can even open the thread and start typing something right there in the thread as well.

And finally, you can also delete.

So I deleted a test message and let's also edit Hello World.

Let's change that to Hello Doctor.

There we go.

So our chat just got so much better by using built-in Stream Chat components.

Of course, I've shown you that you can do everything yourself.

You can build the Css, the Jsx, everything there is, but you can also pick and choose from the wide variety of stream React components.

Let me show you what I mean.

Going to their website, we can go to Chat Messaging, open up the docs, and then under React, you'll see Ui components.

Here are some of the components we've just used.

There's the chat channel list, channel, message list, and everything you need to know to build your own fully custom thing.

If we scroll down below, you'll see here the custom code examples: emoji, picker channel, a lot of different things that you can pick and choose from.

So what I really liked about Stream is that they offer you the api just raw data.

You can build everything with it, but they also allow you to pick and choose from pre-built good-looking components as we've done it right now.

Great! Our chat just got so much better.

Now if we click right there, you can see that the edit channel and the add channel buttons have not been yet created.

So let's first add a button to create a channel and then the entire dashboard view to create name channels invite different people into it.

and then we'll be able to browse through a lot of different channels that our users will be able to create.

Let's do that right away.

We can add the button to add a new channel by going to client source components and then that's going to be channel list or team channel list.

If we scroll down, you'll see that we're currently displaying the text of channels if the type is steam or direct messages.

If the type is not team, we can even see that in the code.

Right now we have a channels header and a direct messages header, but now we have to add a plus icon right here if we want to create a new channel or a new direct message.

We even left it to do right here.

Button add Channel So as you can see at the top We are already importing an icon from assets called add Channel and that is a simple Svg.

But on that Svg, I've already added the onclick property and that's simply going to set the state of Create type to type meaning either a direct message or a team chat and it's going to trigger the set is creating to be true.

That way, our new window for the channel creation is going to open.

So what we can do is simply call the Add Channel component.

Currently, we don't have access to the props that we have to pass to the add channel.

even the team channel list doesn't have them.

so let's see where the team channel list is getting called.

We can just search it like this: team Channel list and we can see that it's getting called into the channel list container if you remember correctly.

If we go back to the app, we sent some props to the Channel list container, but we haven't yet used them.

So let's copy these variables, go into the Channel list container and now you can simply put curly braces right there to destructure the props and then paste all of the variables we're passing from app.

So let's take all of these variables and let's paste them right inside of our team Channel list right here and under messaging as well.

So I'm going to paste them.

and now we have to say is creating if we copy it and is equal to is creating then Set is creating also is equal to Set is creating one more set Create type is equal to Set Create type and finally, Set is editing is equal to Set Is editing great.

Now we're passing all of the necessary props to our Team Channel list both for messaging which is a chat for two people and then also in the Team Chat which is for chat of three or more people.

Great! Let's save it and now we can have access to these same props right inside of the Team Channel list.

So one more time I'm going to copy these go into the Team Channel list and now we have access to them right inside of here.

The way we're doing it right now is not ideal.

We had to pass these props from app to the channel list container and then one more time to the Team Channel list.

A preferred way would be to switch it to a context api and if this video doesn't end up lasting too long, we're going to make that switch at the end.

If not, please let me know in the comments if you'd like a special video or a project only focusing on the context api.

With that said, let's go to our Team Channel list and now we can make use of these variables.

More specifically, we can simply pass them into the Add channel.

So I'm going to go back to the Channel List container and right inside of here.

I'm going to copy these four values.

We can simply paste them right there and indent this properly.

The last thing that we have to pass is the type variable.

We're going to make a check to see if type is equal to team.

In that case, we're simply going to have a string of team.

Else, we're going to have a string of messaging.

With this done, our Ad channel is successfully going to trigger the set is creating state.

Now let's check it out and see if we can actually see the Add Channel button.

Back on the application, you can see that we have two clickable buttons.

Let's try to create a new channel.

Once I click here, you can see that we have a blank Create Channel component.

This basically means that we've already created the Create Channel component, but we haven't implemented the logic.

So let's do that right now.

Let's move into the Create Channel component right here.

and as you can see right now, we don't have anything.

So what we can do is we can first import use Chat context which is going to be coming from Stream Chat React.

Then we are also going to import a new component called user List That's going to be user list and that will be coming from that slash meaning that is a component that we are yet to create and we need one more thing from the assets and that's going to be close.

Create channel icon and that's going to be coming from dot dot slash assets.

Great! Now let's create the layout.

First, let's create the channel name input.

That's going to be a component above our current functional component called channel name input and that component is going to accept a few props.

It's going to accept a channel name prop which we're going to give the default value to be equal to an empty string and also set channel name.

This is going to be a function so we can have a return there and inside of there we can return the Jsx.

More specifically, we are going to have one div.

that div is going to have a class name equal to channel dash name, dash, input, underscore, underscore wrapper inside of there.

We're gonna have one B tag and that B tag is simply going to say name.

Then we're going to have an input tag and that input is of course going to have a value and it's also going to have the on change property.

Right now we're going to leave them blank and finally it's going to have a placeholder which is going to be equal to channel name and I'm going to put no spaces here because we have to create a channel name with no spaces in between and we're also going to have one more P tag which is going to say add members Let's quickly create a value and an on change for this and let's change the typo to on change.

So what we can do is say const handle change is going to be equal to a function where we get the event and then in there we can say event dot prevent default We discussed a few times what that does that prevents the browser reload and finally we're going to use the event target value to populate the channel name.

So on change we can call the handle change and the actual value is going to be channel name.

Okay now let's use that inside of our component just to see how it looks like.

So it's going to be channel name like this.

I'm going to save it and if you click a plus here you can see we have name and then channel name looks like our no spaces is not fitting here so I'm just going to remove it from the placeholder.

Okay, let's remove it from here and for now we're going to comment out this component.

Or you know what, let's completely remove it because we have to add some other layout details.

First of all, we're going to have a Div that's going to have a class name equal to create Dash Channel Underscore underscore container.

Inside of that div, we're going to have one more Div which is going to have a class name equal to create Dash Channel Underscore underscore header and in there we can check if we're currently on the team chat or messaging chat so we can say if create type is equal to team.

In that case, we can simply say something like create a new channel or otherwise we're going to simply say send a direct message great And this create type is coming as a prop to our create channel component.

so let's see if we're passing that value correctly.

One trick that you can do is go to search and then open the opening component bracket and then the name of the component.

That way you'll be able to see where you're calling the current component you're working on.

If we go there, you can see that Indeed, we are passing two different props that we can use so we can go back and use these props.

Create Type and Set is creating So right here.

Destructure the props, create Type and Set is creating great.

Now below that P tag, we are also going to have a close create Channel icon and we're simply going to pass.

Set is creating straight to it just so we can reset it to not creating below that div.

We're going to have one more logical block and we can say if Create Type is equal to team then and only then we can show the channel name input that is this component we just created.

So we're going to call it as a self-closing tag and remember we have to pass two props to it which is the channel name and set channel name.

So right there I'm going to pass the channel name and also the set channel name to be equal to set channel name.

But as you can see right now we don't have access to those values and usually whenever you have a pair of something and set something that's going to be a state variable.

So just at the top of our create channel we can create a new use state like this and it's going to be channel name, set channel name and at the start it's going to be set to an empty string.

We also need to import use state from React at the top Just like this.

Great Now let's save it and see how it looks like.

Now if we click channels, add we have create a new channel and then we can enter the channel name and also add members.

But if we go to direct messages right here, send a direct message.

We don't have that naming of the channel because it's just going to be a direct message.

As we discussed previously, the user list component doesn't exist yet.

If we go to client source components, there is not a user list component.

So let's create it right now.

Components: New File User List dot Jsx Our user list is going to be a longer component.

We're going to have a few functional components inside of here.

so let's start at the top import React and we're also going to need use effect and also use state hooks and that is coming from React.

Then we're going to need the avatar component and also use chat channel and this is coming from Stream Chat React.

Finally, we're going to need import invite icon and that is coming from dot slash assets.

Great! So let's create our primary functional component which is going to be const user list and that's going to look like this.

We are of course going to have a return and there we can return a div that's simply going to say user list Of course we have to switch this as well and we're going to do export default user list.

Great! Now we have everything ready.

We have to go into our index.js and export that component from there and finally back in the create channel.

We should be able to see our user list.

There we go.

User list is showing up right here, both on channels and on the direct messages as well.

Now, considering that we'll be making a lot of changes to our code for the user list, I'm going to pull my browser to the right side and go to the left so you can see in real time what's happening.

Okay, let's go back to the user list and there we are.

So what we can first do is to create one more helper functional component which is going to be called Const List Container and that's going to be a React functional component.

All React functional components have access to a specific prop called children.

So whatever components you render inside of this that's going to be populated into the children prop.

In this case, we can say return and we're going to have a Div That Div is going to have a class name equal to user dash list, underscore, underscore container, and we're going to have one more Div inside of it.

That div is going to have a class name equal to user dash list, underscore, underscore header, and inside of there we can simply have two paragraphs.

The first one is going to say user and the second one is going to say invite finally below that we want to render the children.

I'm going to save that and finally, we can now use that list container inside of our user list.

So right here instead of the Div, we're simply going to use the list container As you can see, it added the headers for the user and the invite, but the user list still remained there because we are rendering it as children below the user and the invite.

Now we can start creating the second helper functional component which is going to be called Const user Item and that user item is again going to be a functional component, but it's going to be a bit more complicated.

Let's first create the return Jsx right here.

So we want to have a div and that div is going to have a class name equal to user dash item underscore underscore wrapper Inside of this div, we want to create one more div and this one is going to have a class name equal to user dash item, underscore underscore name dash wrapper inside of there we can show the user's avatar so we can say avatar that is going to be a self-closing tag and we want to get access to the current user that we are mapping over right now.

We don't have access to that, so let's see how we can get all of the users into our list container and therefore into the individual user items.

To get the users, we'll have to go inside of the user list and we'll have to create a new state const users and also set users and the default value is going to be equal to an empty array.

Then we have to create a use effect hook which we're going to call when something changes.

More specifically, we want to call it once filters change because sometimes we want the users for direct messages and sometimes when filters change, we want users only for channel messages.

So instead of this use effect we can create a new function const get users and that is going to be an async function and in there we're going to of course get the users.

So first, we're going to check if we're currently loading something and in that case, we're going to go outside of the function.

We don't want to get users if we're loading something and that loading is going to be a state field so we can say use state autofill it And then there we can say loading and set loading at the start that's going to be set to false.

If we're not loading something, we can set that loading to be equal to true.

Because we're starting to get users, we want to enable our loading below that I'm going to create a try and catch block in there.

we want to query the users and we are going to query the users from the use Chat Channel context.

More specifically above, our use states we are going to get the client so const in curly braces client and that is going to be equal to use chat channel.

But I've just noticed that this is not supposed to be channel.

it's supposed to be context.

Whenever you have a form like this, get something from use something.

That means that it's a context or a hook so let's copy this.

and instead of use chat channel, let's import use chat context.

So from here we're getting a client, but what are we going to do with that? Well down below, we can say const response is equal to await client dot query users.

So this is going to allow us to query all the users based on specific parameters and we can specify parameters like this in the first object.

we're going to have the Id equal to and then we want to have one more object and then say dollar sign n e not equal to client dot user id.

So basically we are excluding the queering of users for the user with the current Id.

We don't want to find ourselves there because we are the people adding different users to the channel.

Okay, looks like that.

I saved my file for the first time in quite a while and I've noticed that we haven't declared our filters yet.

I've just noticed that we don't even need these filters yet because we will be filtering based on the fact are we currently on the direct messages or on the channels.

We don't need any specific filters for that and then we can pass some additional information to our query users object.

If you hover over it, you'll be able to see that we have the sort options to sort by specific variable and also the options object.

So the second object we'll pass here is going to be Id is equal to one.

This is just the way we want to sort specific things.

Here is the explanation.

Then third thing are going to be the options and in the options we're going to provide our limit.

So let's say that we want to limit only to the eight users.

Great, That's about it.

For our response.

I have to rename it because I had a typo.

Now let's see if we actually have anything in the response.

I'll say if response.users.length In that case, we simply want to set the users to be equal to response.users Else we're going to have a special state field called is list empty or just list empty.

So let's create it.

use state list empty and set list empty at the start.

that's going to be set to false.

So if we don't have users, we can simply call the set list empty and set it to true.

Finally, if there was a problem while catching the users, we can simply console, log the error and after this whole part is done, we can finally set the loading back to false.

Great.

Now we've created the function to get the users.

now.

let's actually call it if there is a client means if we are connected only then do we want to call getusers function.

Let's do it.

Save it and see if we're expecting something.

Well, with that, we're simply populating the users, but we're not using the variable yet so we want to map over the users and for each user, we want to show a user item.

Let's do just that.

right inside of our list container.

We're going to have a loading property and if we're currently loading in that case, we want to show a div which is going to have a class name which is going to be equal to user dash list, underscore, underscore message and that div is simply going to say loading users dot dot so we can put that here in new pair of parentheses with a column.

If we're not loading.

we want to see if we have the users so we can say if users question mark dot length And finally we want to say users question mark dot map We're mapping over the users in here.

We have a callback function and for each user, we want to render the user item component.

That's the component we created right here at the top.

Of course we want to pass some things to it.

So we're first going to provide an index which is going to be equal to I, We also want to provide a key which is going to be equal to user dot Id, and finally, we want to provide the user property which is going to be equal to the user we're mapping over.

Now back in the user item through the props, we can access the user object and now we can get his name, avatar, and everything else.

So the avatar component has the image property and that is going to be equal to user dot image.

It also accepts a name property which is going to be equal to user dot full name, or user dot Id, and also you can set the size equal to the number of 32. Let's save it.

If we hover over it, you'll see that this is the Javascript Mastery user.

So far, we don't have a lot of users.

We are currently logged in as Dr.

Smith, so that's why we cannot see yourself.

But if I remove this part here, you're gonna notice that we're gonna have two users: Dr.

Smith and Javascript Mastery.

But Dr.

Smith is ourselves and we cannot invite ourselves to the chat we are creating.

So that's why we're saying if our Id is not equal to the current Id of the user.

There we go, we disappear from the list.

and now alongside Avatar, let's add a name for that user.

We can do that by adding a paragraph tag, and now let's add a name for the person we're inviting.

We can add a paragraph, set the class name to be equal to user dash item, underscore, underscore name, and then inside of here, we can simply render user dot full name, or user dot Id.

That means if for whatever reason we don't have access to the full name, we can simply show the user Id.

Let's save it.

And as you can see, this is Javascript Mastery.

Now let's add icons to keep track of if we're inviting the person or not.

We can add an icon by simply putting invite icon svg right here and saving it As you can see this is a filled check mark, but we can also have a self-closing div and then inside of there we can add a class name equal to user dash item underscore underscore invite dash empty If we do that, you'll notice that we have an empty checkbox.

So now we have to be able to toggle between them and we can do that by creating a new use state field So we can say use state and we can call it selected So selected, set selected and the initial state is going to be false.

Based on that, we can make use of that like this.

if selected, then we show the invite icon, else we show the empty div.

So let's save it and as you can see right now, we have just the empty div which is like an empty circle.

So now how can we toggle between those? Well, we're going to add the on click property straight to this div and what we can do on click is simply handle Select.

We're going to create that handle select function right here.

Const: Handle Select Inside of there we can simply set selected inside of there.

we get a callback function with the previous selected so we can say pre-selected and then we can simply return, not pre-selected This is how you do it in React when you want to modify something by the previous value and now if you see that we can click and toggle the users on and off.

But the problem happens if you want to invite more users, if we had a second user right there then you wouldn't be able to toggle on and off both of them We have to keep track of which ones are toggled on and which ones are not to do that.

We can go back to our Create channel and then right inside of here we are going to create a new use State field, use State and in here we can call it something like selected users.

Then we're going to have set selected users and at the start we only want to input our own Id because we always want to be in the chat that we are creating.

So how can we get to our Id.

Well we can do that by using the Use Chat context so we can say const client and also we're gonna need set active channel that's coming from use Chat context and we call it as a hook.

Of course there's the equal sign in between and now we have the client and we can simply get the user Id right here at the first element in the array by saying client dot, user Id Id all uppercase or if there isn't one, we can simply say or empty string.

So what we've done is we've just created the selected users field and immediately added ourselves to that group.

Okay, now that we have the selected and the Set selected users right here, what we need to pass into the user list is going to be the Set Selected Users Variable Set Selected Users is equal to Set Selected users.

We can go to our user list and then right inside of here inside of our user item.

We want to pass that over one more time.

Set Selected Users Right now it's undefined.

so right here inside of the user list, we need to get that Set Selected Users Great! Now we have access to the Set selected users right here inside of the user item.

So what we want to do is we first want to check if the user has been selected so we can say if selected.

In that case we want to set selected users to be equal to then we're going to have a callback function and in here we get Prev users.

So what we can say is Prev Users Dot Filter We get that Prev user and then we want to filter the Prev user that doesn't have an Id equal to to the user dot Id.

So basically we are keeping all of the selected users so far but removing the one that we've clicked right now.

So if we had two more of these and if we clicked all of them and then click the third one, we would just remove the selected user from the third one and keep it on the first two ones.

I know it's a bit confusing but I hope it makes just a bit of sense and then we're gonna have else and then on else.

We want to do set selected users.

We are again going to get prev users as a callback function.

Let's make sure to close it properly and in this case we want to add a user so we can create an array where we spread all the previous users and finally append our current user Id to it right here.

It should have been prevusers and not user.

So the above part is just filtering out the currently clicked item if it was clicked.

but this line is adding one more selected user.

As you can see we are spreading over all of the previous users plus adding the one we just clicked.

Great! So that part with the user item is now done.

The final thing we can do is some slight error handling and handling the situations where we have no users.

So what we can do is add one more use state field There We're going to say error and set error at the start.

that's going to be set to false.

So let's set it to false right there and right here.

instead of Khan's log in.

The error.

we're simply going to say set error and we'll just say true now based on these conditions.

instead of rendering the list container, if we have an error, we don't want to render that.

So what are these conditions going to be? So we're going to write if there is an error.

In that case, we want to return some Jsx more specifically, a div Really similar to this one, it's going to be a div a user message but instead of loading users, we're going to say error loading please refresh and try again but make sure that that is inside of the list container.

So I wrap that inside of the list container and it's going to be just like this.

In this case, we cannot see that arrow because we have users.

but if we didn't have any or if there were some connection issues then we would see that error.

And one more thing is we're going to copy this entire if statement and just change the error part to be equal to list empty.

So if our list is empty in that case, we simply want to say no Users found great.

We have the loading states, we have the no user state, the error state and if everything works out, we are displaying our users and we can toggle the user invite, on or off.

That was it for our user list.

It was such a long component but now we can go back to our create channel.

We can remember what we had the name, add members there is the name and there is the add members.

And finally we can add a button to make an invite of the user to our channel to create a channel.

We just need to add one more div below the user list and that's going to be a div with the class name equal to create Dash Channel underscore, underscore button, dash wrapper inside of that div.

We're going to have a P tag and that p tag is going to check on what is the create type and if it's currently team.

In that case we want to say create Channel.

Otherwise we want to say create message group Great! Let's save it and check it out.

As you can see, there is our button at the bottom and now we just have to add the on click property to this div.

So on click let's do something like a create Channel function just below these use states.

We're going to create a const Create Channel function.

It's going to be an Async function and we are going to get the event as the first parameter inside of there.

We can first say event or E dot prevent default not to do a browser reload and then finally we'll have to create a new channel.

We can do that by first opening a try and catch block to make sure nothing goes wrong and this is how we create a new channel.

New channel is going to be equal to await client dot channel.

and that's going to be the function that's going to create a channel.

We have to pass a few options into it.

First of all, we have to pass the create type.

Is it a messaging channel? Is it a theme channel? Then we have to pass a channel name and finally we have to pass an object that's going to contain the name as the channel name and also the members.

And this is the most important part.

As members, we're going to add our own selected users.

Great! Once we finally created the channel, we can just say await New Channel dot Watch We want to keep watching that channel we want to see whenever there's a new message in that channel.

And finally once the channel is created, let's do a clean up.

First we're going to reset that field.

If we go here, you can see there's a field with the channel name.

So let's reset that that's going to be set channel name equal to an empty string.

Then we're gonna set is creating to be false because we're no longer creating a channel, we just created one.

Then we're going to reset the set selected users so we can say set selected users and we're going to reset that back to an array containing only us one more time.

So client dot, user id We always want to be there in the channels we create.

And then finally we're going to switch that channel by saying set active channel is going to be equal to to the new channel.

And finally, if we have an error, we simply want to do console.log right there.

Console.log Error Great! This is going to be it for the entire channel creation process.

Now we should be able to finally see what channels and direct messages we have right here on our lists.

So let's go under new channel.

So right now I'm going to maximize this window.

We are going to go under channels.

I'm going to name the channel something like Doctors Meeting and let's invite Javascript mastery.

Let's create a new channel.

And there we go.

We are in.

Let's send a first message, something like hello and as you can see Dr.

Smith the message is there.

Unfortunately, the channel didn't seem to appear on the left side, so we need to see what's up with that.

Also, if we go here under edit, you can see that we still haven't implemented the edit feature.

Now let's reload and unfortunately, yeah, there still is not a doctor's meeting channel on the left side.

If we tried searching, still nothing happened.

So these are the things that we have to fix to make this work fully.

The channel was indeed created and we can verify that in the Get Stream dashboard, but we still cannot see it on the left side.

so let's fix that right away.

to make our channels and direct messages appear, we can go back to our channel list container inside of here if we scroll down.

We left our filters to be empty so we are not filtering any data.

We're not trying to look for any channels, so let's fix that right away.

So first in here we have the sidebar, then we have the company header.

After that, let's create some filters.

So right here I'm going to say const custom Channel Team filter and that's going to be a function and as a parameter we're going to get a list of all the channels there.

we can return channels dot Filter So we want to filter out the channels and we get each specific channel and which ones do we want to leave out.

Well, we want to keep only the ones where the channel dot type is triple equal to team because this is our team filter.

Now we're going to copy that same function and we're going to call this one custom channel not theme but rather messaging filter and we're going to set the channel type to messaging.

Great! Now where can we use those filters That's going to be here in channel Render Filter Function In here we can simply say custom channel theme filter and for the second channel list right here we are simply going to paste custom channel theme filter but this time it's going to be messaging Okay now that we have the channel render filters before we fill in the other types of filters, we need to do some quick renaming.

I've made a mistake when calling this component the Channel list container.

This one should be called the Channel list content.

So this is just the content for our container and then the actual component is going to be below and we can create it right here.

That is going to be const Channel list container.

That's going to be a functional component and inside of there we can of course do some logic.

These props are going to be in curly braces.

Set, create type, Also, Set is creating and finally, Set is editing great.

Now we're passing these three props and we're going to have just one more state value.

This channel list container is going to give us the logic for that sweet animation you saw for mobile devices.

So we need to be able to toggle the container based on the width of the screen.

So let's create a use state field and let's call it toggle.

Great! We have to import the use state at the top.

So right here we're going to import use state and let's scroll down the initial state for the set toggle container is going to be set to false.

Also, make sure to put a capital T right there.

So what Jsx Are we going to return from here? Inside of the return, we are going to return a react fragment.

Inside of that fragment, we can return a Div and this div is going to have a class name equal to channel dash list, underscore, underscore container, and inside of there we can render our channel list content.

Of course, we were using some props in our channel list content as you can see right there.

so we have to make sure to pass all of the props from our channel list container to the channel list content.

Of course we have to space everything out properly and then set the equal values to be equal to the names themselves.

We can do that by using some shortcut magic.

There we go and we can do the same thing for set is editing.

There we go.

The only thing we don't have to pass here is the is creating property.

We need just these three.

Great! Now below this div, we are going to have one more Div and this div is going to have a class name equal to channel dash list, underscore, underscore, container Dash Responsive.

So this one is only going to be visible when we are on mobile devices, so we are going to give it some inline styles.

More specifically, style is equal to left toggle container and that is going to be either zero percent.

So let's put that here zero percent or that's going to be something like let me put it like this: something like minus 89.

I found this value to work the best.

Basically, it's going to pull from the left side to the right and it's going to have 11 of the width.

Finally, we need to give it a background color so you can say background is equal to and that's going to be hexadecimal string 005 Ff.

Great! Now we have everything.

It is complaining about the toggle container variable.

because I have this column here, we don't need that.

With that, we created our div and we need to have one more div inside of it so we can create the final div here.

This div is going to have a class name equal to channel dash list, underscore, underscore container, dash toggle and it's also going to have the on click property on click.

We are going to simply call a function set toggle container and we want to toggle it off.

So as we discussed, we are going to get the previous toggle container and we're simply going to return not pref toggle container.

That's how we toggle values in react state and finally below this div we just created, we're going to add our channel list content.

We can basically copy what we had here.

So this same thing, let's simply copy and paste it here and we're going to add one more prop to it.

This time, that's going to be the set toggle container is equal to set Toggle container.

So why do we have two different divs with two of the same components? This one is for the desktop version and this one is happening on mobile.

Great! So now we have two different versions, the channel list content and the same channel list content.

but the one for the responsive version where we're passing the set toggle container.

We are going to use that in just a moment.

But for now, let's finish these filters right here and here so that we can actually see the channels in action.

So to get these channels, we're going to get something from the use context.

So right here at the top of the channel list content, I'm going to say const lowercase and we want to get the client object that's going to be equal to use chat context.

So once we get this client, then we can create the filters object and we can say const filters is equal to an object and then in there we can say members colon that's going to be an object and we want to say dollar sign in.

That means included And there We can simply say client dot user Id So that means that we want to get all of the channels and direct messages where our user is included.

Great! Now we can copy that variable and paste it right here instead of this empty object and right there in the channel list as well.

Now let's save it and check it out.

And as you can see the cardiology we previously created that was the demo chat and the doctors meeting channels are now here.

We cannot yet switch between those, but we're going to implement that soon.

but for now, we are at least seeing them on the left side.

We don't yet have any direct messages, but let's try to create some.

Let's try to invite Javascript mastery, create message group and let's say hello.

There we go.

Something happened, but it doesn't look like a real direct message yet.

We'll have to look into this component and see if we've created everything correctly for the direct message output.

With that said, let's finish the left side with the mobile toggle for the responsive view so we can do that.

Considering that we are now passing this set toggle container variable to the channel list, so if we scroll a bit up, you'll see that there is our channel list content and then in there we can simply get the set toggle container.

Now, we can pass that variable deeper into the theme channel list right here and we need to pass it in a few more places like into the theme channel preview and we have to copy the same procedure right here as well for the team channel list and Team Channel preview down below.

Now that we are passing those values to the team channel list and the theme channel preview, let's see where we have to pass them to make it work.

So right here at the top, we can get one more prop which is going to be called set toggle container.

Now that we're passing the set toggle container, we can go inside of the theme channel list and team channel preview to see where we need to use them.

First of all, we can accept them here as a prop at the top and then right here.

we can pass it over to the add channel by simply doing set.

Toggle container is equal to set toggle container.

Now if we go back to the channel list container, we can go to the preview theme channel preview.

We are passing it going there.

We can also get it right here from the props and in this case we'll have to do something on click and as you can see, this is another feature we are yet to implement clicking on a specific channel to open the messages for that channel.

So while we're here, let's make that work right away.

To make that work, we also have to make use of all of the other props we are passing into this and right now we are not passing any.

So what do we need to pass? Well, that is going to be the same once we're passing here.

Set is creating, Set is editing and that's going to be it.

So I'm going to copy these two and simply paste them here.

Set is creating and Set is editing.

Now we can go back to the Team Channel Preview Get the Set is creating and also Set is editing and finally we can use those value to preview a channel.

So we need to call Set is creating and set that to false.

Because we are no longer creating a channel, we want to see the messages for a specific channel.

Then if we're currently editing, we don't want to do that anymore.

We want to see a specific channel and then finally we want to see if the Set toggle container exists.

So Set Toggle Container and if it does, we want to call it as a function Set Toggle Container Remember we are going to get a previous state and we can simply do not previous state.

So we are doing this if because on our desktop devices we won't have this set toggle container but on mobile we will.

So we want to toggle it on and off.

and then finally we have to set the active channel and we can get the value for that right here From the Props Set Active Channel and we simply need to call it right there.

Set Active Channel and we pass in the channel variable.

This should allow us to switch between the channels before we go ahead and check it out.

Let's first go to the Channel list container and make sure that we have these props right there also in the upper preview because they should be the same.

So right here I'm going to copy these.

That's going to be set, is creating set is editing and set toggle container and paste them right here.

These have to be the same now.

let's save it and take a look in the browser.

Now we're currently on the direct message to Javascript Mastery, but if I switch to Cardiology, you can see we successfully switched to another channel.

We can also go to the doctor's meeting and damn is it nice to see how everything is working.

well.

we have doctors meeting cardiology and then we have direct messages.

Now that we can create new channels, also create new messages and switch between the channels.

Let's see what's happening with the styles of our direct messages and then we're going to implement the edit channel functionality.

It won't be that hard as you can see most of the logic for everything has already been done.

so let's keep it going to figure out what's happening with our direct channel preview.

We can go into Team channel preview and then right in here.

This is the channel preview for the channels and this is the preview for direct messages.

So in here we're looping over the members and then we're showing the image and the full name for the member.

but for some reason this is not getting displayed.

So let's simply console.log members 0 right here.

so that's going to be Members 0. Let's see how our user looks like.

So if we open up the console we can inspect and right here we can have two different objects and this is going to be the Javascript Mastery user.

Javascript Mastery is going to be the only account ever on this platform that we haven't created ourselves.

All the other accounts are going to be created using the sign up and the sign in form, but this is the default stream account and unfortunately this one doesn't have the full name property.

So what we can do to fix this is we can simply right here say or members 0 and then we can use the Id So that's going to be question mark dot, user question mark dot and that's going to be Id.

So we either show the full name or we show the Id and if we go back, take a look at that.

We have a little J thing there and Javascript Mastery.

But now let's actually test this out with a real user.

Of course right now we're logged in as Dr.

Smith, but we need another user to be able to chat with him.

So let's log out and create one more account.

I'm going to close this click log out and right now let's create another doctor.

Let's do something like Dr.

Miller Dr.

Miller as well.

Phone number is not important for now.

We can enter the same avatar url and the password can be something simple.

Let's click sign up.

as you can see there are no channels yet, but let's create a direct message with Dr.

Smith.

I'm going to click create message group and there we go.

We only have an Id.

Unfortunately, there doesn't seem to be a full name so let's open up the stream dashboard and see what's happening.

If you go to the dashboard.get you are going to be on your app overview, but we can go to the app Explorer right here.

You should be able to see all the users and let's check it out.

There is our Dr.

Miller looks like that, he has his username here and here's our Dr.

Smith.

The full name is there as well, but let me show you something once we actually log out and try to log in one more time as Dr.

Miller and then I'm going to enter the password, log in.

as you can see nothing is there.

same thing as before.

But now if I go here and I visit Dr.

Miller, the full name is actually going to be empty.

Why was this string cleared? Well, let's check it out.

So what's happening is that we have a small mistake in the Auth component.

When we log in, we're filling in these values the username, full name, user id, and token.

But think about it, if the user is logging in, he won't have to type in his full name, Therefore, it's going to remain as an empty string.

So instead of getting the full name here, what we can do is just get it from the data that's returned back from the database.

So here we can get the full name.

but then on the sign up when we're sending the data to the database here, it has to be form dot full name.

So this is the data from our input only on the sign up.

Great! That part is now fixed.

So let's try to create a new user and test it out.

I'm going to log out.

Let's try to sign up as Dr.

James.

That's going to be Dr.

James.

We can use the same avatar and password and I'm just going gonna click sign up now that the Dr.

James was created and we sent a message to Dr.

Smith.

Let's try to log in as Dr.

Smith and see if the issue has been resolved.

So I'm going to log out and sign in as Dr.

Smith.

There we go.

Our issue was fixed because we can now see Dr.

James right there to test it out properly.

Let's log out one more time and log in as Dr.

James.

So that's going to be Dr.

James.

And there we go.

Now we can see Dr.

Smith once again.

That's great.

I'm going to log out and finally one more time bear with me to test this out properly.

We're going to log in as Dr.

Smith and then I'll see how it looks like.

There we go, Dr.

James is still there.

We can ignore this person right there.

or as a matter of fact, I'm going to delete everybody who's not Dr.

Smith and Dr.

James because we had an issue that caused their data to be corrupted.

So I'm going to hard delete this user right there.

and from now on, we shouldn't have absolutely any problems while we're there.

Let's also delete all of the channels that we have.

I've deleted all of the channels besides the ones that have proper names.

So now if we go here, you can see that we can switch between the channels and let's try out the direct messages.

I can try to message Dr.

James and say something like hello and there we go.

Dr.

Smith said hello to Dr.

James.

That's great.

That means that our direct messages, our channels switching between the channels.

Everything seems to be working great.

One thing that we still have to do is fix the edit channel functionality.

So if we want to go to cardiology and add a new user, we need to be able to do that.

Right now, our edit channel is empty.

so let's do that.

And then we're getting close to the end where we're going to implement Sms notifications using Twilio.

So let's keep it going.

Let's close all of our files and folders to have a clean working environment.

and let's go to client source components and then finally Edit Channel.

This is the component we need to focus on right now.

Inside of the edit channel, we're going to import React as well as the use state.

Then we're also going to import the Use Chat context that is coming from Stream Chat React.

We are also going to need one more component and it's the one we already coded out.

It is going to be the user list.

Remember we use the user list to create a new channel and we'll say from that's going to be dot slash and finally we're going to need one more thing from the assets and that's going to be close.

Create Channel That's going to be coming from dot slash assets.

The first thing we're going to add in here is going to be a channel name input component.

And if you remember correctly, we already created something like that.

So we can go to create channel component and simply copy the channel name input, go back to edit and paste it at the top.

We are going to reuse this component.

Now let's start with working on the edit channel.

Our edit channel is going to have a Div that's going to have the class name equal to edit, Dash Channel, underscore, underscore container, and inside of there we are going to have one more div and this div is going to have a class name equal to Edit Dash Channel underscore underscore header.

Inside of that div, we can put a paragraph so let's put a P tag and we can simply say edit channel Now let's also put a close icon so we can say close create channel icon and in there we have to pass.

the set is editing prop as set is editing this prop we are receiving from the props at the top so we can simply destructure it from the props right here.

Now below this div, we are going to call the component we created above, which is the channel name input.

So that's going to be channel name input, a self-closing component and we have to pass in the channel name as channel name and we also have to pass the set channel name as set channel name.

So you might be wondering where are we getting these values from.

Well, we can get the channel name from the chat context so we can say cons in curly braces channel and that's going to be equal to use chat context.

Then for the channel name or set channel name, we can create a use state field.

So right here we can say use state channel name also set channel name and the default value is going to be equal to channel question mark, dot data question mark dot name So if there is already a channel name, we'll try to get it from the channel.

I've noticed that I've misspelled the name here that's going to be channel name and now we have both the channel name and the set channel name.

The last thing we have to do is render out the user list.

So right here we can say user list.

It is a self-closing component and in there we can simply pass.

Set selected users is equal to set selected users and again selected users.

and the set selected users are state fields which we don't have already.

So let's create a new use state field and we're going to create our selected users and also set selected users with the default value equal to an empty array.

Great! Now we have the header, channel name input and the user list.

Let's just add a button to save the changes and we are almost done.

So it's going to be a div with a class name equal to edit, dash, channel, underscore, underscore button, dash wrapper and inside of there we can simply say something like Ap tag.

That's going to say save changes, let's save it and see how does it look like If we go back you can see this looks similar to what we had with the creation of the channels because we are using most of the same components.

So now if we switched to the doctor's meeting you can see we can invite new users direct messages don't have the added channel because they are not channels but cardiology and doctors meeting have them and we can invite new users or simply change the name.

Great! Finally, the button doesn't do anything yet so let's go ahead and create a function that's going to save the changes.

We are going to add the on click on this button or a Div and on click.

We simply want to call the update channel function.

We can declare it right here Const: update channel and that is going to be an async function inside of there.

We are going to get the event and as always let's call the event dot prevent default.

Now let's see if the user has changed the name.

We can say const name changed and that's going to be equal to if channel name is not equal to in parentheses channel dot data dot name or channel dot data dot Id.

That means that the name has been changed so if name has been changed inside of the if we can simply say await channel dot update and then inside of there we can pass an object with what we want to update and the thing we want to update is going to be the name to channel name.

We can also set the text for the update so in a new object as a second parameter we're going to say text is equal to a template string channel name changed to and then in here we can say simply channel name great Finally, if the name hasn't changed but if the number of users has changed so if selected user is that length meaning if we added some new users in that case we want to await channel dot, add members and simply pass in the selected users.

that is going to be it.

And once we're done we have to set channel name back to now.

We also have to set is editing back to false because we're done with the editing and finally we have to set selected users to be equal to an empty array and with that we are done with the edit functionality.

Let's go ahead and try it out.

Let's try to go to the doctor's meeting and let's try to change it to something like emergency and I'll also try to add Dr.

James.

I'm gonna click save changes and there we go.

Channel name change to Emergency at Friday at 6 Pm.

Great! That means that this part works perfectly.

As you can see, our application is getting better and better and it seems like we have a fully working chat by now.

I know this was a long video so if you're still here and watching, definitely make sure to leave a like and comment down below.

With that said, let's check if our search is working so I'll try to search for Dr.

James, but unfortunately nothing seems to be coming up.

Let's see what's happening with our search.

We can look into our search by going to the channel search component and would you look at that? We even left ourselves a to do right inside of here.

So in the channel search let's make it work.

What we have to do is we have to use this chat context to get the information about the active channel.

So right there we can say const and then the structure, the values client and also set active channel and this is coming from equal to use chat context.

Great! We also have the query and the loading but we're going to add a few more use states that we're going to need.

For example, I'm going to write use state and we are going to need team channels.

We need to know which are the currently active team channels and at the start that's going to be set to an empty array.

Then I'm going to duplicate that and then we're also going to add direct channels and set direct channels.

We need to know which are the currently active direct channels also at the start equal to an empty array.

Now that we have all of these used state fields, let's make our get channels function work.

So inside of the try block let's query our channels.

We can do that by saying const channel response is going to be equal to client dot query channels and then inside of there we need to pass some options.

The first thing we have to specify is the type which is going to be equal to team.

Then just next to that we can specify a name which has to be equal to dollar sign.

Auto complete is equal to text so we want to autocomplete all the usernames and then finally the third thing next to the name is going to be members.

And for members, we can say dollar sign.

Dollar In is equal to an array where we have the client dot user Id make sure that the user is lowercased and the Id all uppercased.

Let's space this in a few rows and this is how it looks like query channels.

Type is theme, name is autocompletetext, and members includes our own user id.

Now let's also query the users.

We can do that by saying const user response is equal to client dot query users and it's the same situation.

We have an object where we pass some information.

So first we can say Id is equal to and then an object and then dollar sign and e.

This is going to make sure that we exclude our current user id.

We don't want to find ourselves on the search but rather next to it.

We can say name is equal to and we can copy this autocomplete text.

So we want to get all the other names.

There we go.

Now we have the user response and we also have channel response and let's see what we can do with that.

We want to put that into a promised at all because we want to start fetching them at the same time.

So what we can do is say const and then square brackets Inside of here we are going to have channels and also in curly braces users So we want to get the channels and the users at the same time and we can do that by saying equal, await, promise dot all and then inside of there inside of an array.

We want to get the channel response and also the user response.

So this is an interesting way.

We did this.

We could have just put the await in front of this one and in front of this one.

but that way if we make a request we'll have to wait for this one to be done and then only start this one once this is done.

but this way we'll be starting both of these requests at the same time they will be happening simultaneously so that's going to make it quicker.

So finally, let's see if we have any channels that length.

Meaning if the channels exist.

In that case, we want to set team channels to be equal to channels.

We'll do a similar thing for the users and say if user is that length then we want to set direct channels equal to users.

If you think about it, a direct channel is nothing more than a user.

Great! This is our get channels function Completely done.

Finally we have to make use of it.

So just below this input, we are going to create last component of our entire project.

At least I think so.

So right here we want to open a dynamic code block and we want to specify if the query exists.

So if the query exists meaning our search term.

In that case, we want to do something like this.

We want to render a component called results.

Drop Down.

A drop down that's going to contain the information about all the channels and users.

Of course we'll have to pass a lot of information into this component.

We have to pass things like team channels is equal to of course Steam channels.

Then we have to do the same thing for direct channels.

Also, we have to pass the loading property so that we know if we're loading.

Also, the set channel property equal to set channel and also set query which is going to be equal to set query of course.

And finally we'll also have to pass set toggle container is equal to set toggle container.

Now let's see which one of these we don't have currently access to and these are going to be set channel.

Set Channel is going to be a function that we can create right here.

Const: Set channel is equal to a function that accepts a channel and in there we simply want to reset the query.

So once we set the channel, we want to set the query to be equal to an empty string and then finally, we also want to set the active channel to be that specific channel.

Now let's see where is the set toggle container coming from? That should be coming from Props.

So let's see if we're passing that into our channel search.

Let's check if we're passing that value through Props.

So I'm going to go to the search, open the opening component bracket, and look for channel search, and it looks like we're not passing any data.

so let's scroll up.

We have the set toggle container here, and we're simply going to pass it through Props right inside of there.

Now, if we go back to the channel search, we can get that variable right inside of here, but make sure to put it in curly braces so that it means that it's destructured from Props.

Great! That means that now we have almost everything, if not everything for our new results.

Drop down component before we go ahead and code it out.

There's one more thing we have to add this file and that is going to be the use effect.

We can create that use effect right here at the top.

Use Effect.

Make sure to add a dependency array in there.

So just at the end we need a dependency array and we want to call the function every time that the query changes.

So if the query changes, and if there is no query in that case, we need to clear the theme channels and direct channels.

So what we can say is set theme channels to be equal to an empty array and also set direct channels to be an empty array as well.

Great! Now we are ready to code out the Results Drop Down Component: Let's go ahead in the components folder, create a new file called Results Drop Down, Dot Jsx, and then in the index.

We can simply use it right here.

Results Drop Down.

Now let's go to our results.

Drop Down.

The situation with our results: Drop Down is going to be incredibly similar to our channel inner.

It's going to be a component with a lot of code, but not a lot of useful stuff that we can learn from.

So in this case, it's going to be linked down in the description alongside all of the other files.

Find the results, drop down, and simply copy and paste it here as you can see the result.

Drop-down component accepts a lot of props, simply does the loading or no channels, and then finally it shows all of the search results.

It has to show them both for the theme channels and also for direct channels.

If we save the file, go back to our channel search.

We need to scroll up and simply import results dropdown from the components.

So right above our assets we can say import That's going to be Results Drop Down and that's going to be coming from components.

So just dot slash Great! And finally, let's check it out in the browser.

There we are! We have our conversation with Dr.

James emergency and Cardiology.

So if I go ahead and search for doctor, you can see that the Dr.

James appears immediately and if you search for something like cardiology, you can see that appears as well and also emergency.

So everything that you search for is going to appear here immediately.

Right now, we don't have a lot of channels, but if we had more, all of them would be listed right here inside of the search.

Great! We are done with the entire authentication search channels, messages, editing the channels, and creating channels, adding users reacting to messages, adding threats to messages, sending images, gifs, and anything you can think of.

You can make this chat completely your own, but as you know on Javascript mastery, we always like to take it even one step further.

We are going to connect Twilio notifications so that if a user is not online and he receives a message, the notification about a new message is going to be sent straight to his phone.

So let's do that right away to send the Sms notifications to the people using our chat.

We'll have to create an account with William.

So to do that, head to Twilio.com link is going to be down in the description and make sure to click sign up.

Once you do that, you can enter all of your information and I'll see you in the dashboard.

Once you sign up, you'll have to verify your email.

So let's go to our email and quickly verify it once you've verified your email.

In this case, we'll also have to verify your phone.

They accept all of the countries in the world.

So yeah, let's go ahead and type in your phone number.

Once you've verified your phone number as well, you can fill in this little questionnaire.

So in here we're going to use Sms and we plan to build alerts and notifications.

How do you want to build it? Well, of course with code.

So what is your preferred coding language That's going to be Javascript And would you like to be able to host your code? No.

In this case, we are going to host it ourselves.

So let's get started with Vilio and there we go.

At the start, you're given 15 bucks for free so that you can use for your email notifications.

That means that you won't have to pay absolutely anything to test this out.

In here.

you have your account Sid and the odd token.

So let's complete the steps below.

First, you'll have to get a Twilio trial phone number.

So let's click here.

They gave us a random Us number so let's just click choose this number.

There we go, we can click done and now that that is done, we have our account Sid and also the Auth token.

So let's go to messaging and then finally try it out and get set up.

in here.

You can see get set up in five minutes.

So let's click start setup.

you have to enter your messaging service name i'm gonna say just medical pager and finally in here you can enter your phone number, choose your Sid, enter the text message and in here you can see the code example of how that message will be sent.

We don't need to do that from their interface because we are going to take this code and do it straight from our express application.

So let's go back to our app and let's code it right away.

to implement our Sms messages, we'll have to go to server and then index.js inside of here.

We'll have to import a few things so just below this require.env We can say const account Sid and we're going to get that from process Dot Env dot Twilio underscore Account Underscore Sid We don't want to simply paste it here because we need this data to be secure.

Then we're also going to need the odd token.

So we can say const odd token is equal to process Dot Env Dot Twilio underscore Auth underscore token And finally, we can set up our Twilio client by saying const Twilio client is equal to require Twilio and then we call it one more time pass in the account Sid and the Aud token.

Great! This is our Twilio account which is going to allow us to make Twilio requests.

So let's set up our process.env We have to add the Twilio account, Sid and the Twilio token.

So back in here just a bit below.

We can add these two variables and now we can copy the values from the web to do that.

We can go back and you can copy the account Sid number straight from here.

Let's paste it right there and then you can click show Auth token right here and then you can copy and paste the Auth token as well.

So let's paste it here.

Great With that, We are done with the initial setup.

Now we can use this Twilio client.

The way we're going to do this is we're going to set up one more route.

We are going to do this using webhooks.

Stream is going to trigger a specific endpoint on our server and then we're going to send a message.

That endpoint is going to be app.post and then inside of here we can set up our route which is going to be simply slash.

We also get the request and the response of course inside of a callback function rec and res and we have a function right here.

Inside of that function we are going to receive some data from stream.

More specifically, we can say const in curly braces we are going to type in message.

Also, user colon is equal to sender.

We're going to get the user who's sending the message and then also the type and finally members.

We are getting all of this data from Rec dot body.

That's the data that stream going to put into our endpoint.

This part cannot be tested in the development mode.

We have to code it out, deploy the project, and then we'll be able to test it out once it's deployed.

So let's code it right now.

it's not that complicated.

I promise.

We are going to add an If statement and say if type is equal to a string of message.new That means if the event is the creation of a new message.

If that is the case, we want to loop over all of the members that belong to the chat the message was sent to, so we can say members dot for each.

In there we have a callback function and for each member, we want to run the following block of code.

We want to first extract the data from this member and we can do that by destructuring and then simply calling the user variable from that member.

Then we can check if the user is online so we can say if not user.online we only want to send messages to the people who are not online.

It wouldn't make sense that people are using our chat and we also send them messages to their phone and only if they're offline only, then are they going to get the message.

So we can run Twilio Client dot Messages Dot Create.

That's a function that takes in an object as options inside of there.

we can specify the body of the message.

So let's do a template string that's going to say you have a new message from Dollar Sign curly braces message dot, user dot, full name and then we can put a dash and simply say again dynamicblock message.txt So this is going to give them the message to their Sms.

Then we have to add a comma and specify the messaging service Sid We can find this by going to Twilio's dashboard right here.

You can see that we have a special medical pager service Id so we can simply copy and paste it.

Let's copy it and instead of simply pasting it here, we're going to do the same thing we did before.

That's going to be const.

Messaging Service Sid is equal to dot Env Dot Twilio Underscore Messaging Underscore Service Sid So let's go to our Env and then inside of here, we want to paste that variable and set that equal to Twilio Messaging Service Sid.

Great! Now we can use that variable right inside of here.

and the last thing is the to property.

Who do we want to send our message to and that is going to be user Dot phone Number.

That's the reason why we're requesting the users to enter their phone numbers at the registration process.

So once the message is sent, we have the dot then which is going to have a callback function.

If the message has been sent successfully, we can simply console log message sent and we have a dot catch.

If we have an error, we can simply console.log the error.

This is going to be almost it.

But think about it, we are also a member or a user and we don't want to send the message to ourselves when we send the message via stream.

So just before the for each, I'm going to run the dot filter method.

That filter accepts a callback function where we get a member and then we want to filter out ourselves so we can say if member dot, user underscore Id is not equal to sender dot Id.

This is simply going to filter ourselves out and then we can send the message to everybody else.

Finally, if everything goes right, we can do Res dot Status 200 and then dot send.

We can simply say something like message sent and we can also return that and down below if it's not a new message if it's another kind of event.

In that case, we can say return, rest that status 200 and we can say not a new message request.

it was just something different.

somebody else has read a message or gone online.

Stream has events for all of these different types, but we are only tracking the new message request and this is it.

This is the entire Twilio code that you need to put there to successfully send real messages from a real phone number to real people.

They just make it so easy.

With that said, let's take one last look into what we've built, see if there are any other issues and if there are none, we are ready to deploy this project.

I went ahead and did some more testing messages, emojis, checked threads.

Let's check them out.

Hello threads work as well.

You can reply to messages, sending images, check.

We can also send Gifs and embed Youtube videos.

Everything is working perfectly.

With that said, we are finally ready to deploy this project.

Let's first deploy the back end of her project to Heroku.

You can head to Heroku.com and then log in or sign up if you don't have an account already.

When you sign up, you'll be greeted with a page that looks like this in here.

On the top right? you'll be able to click new to create a new app.

I'm going to type medical dash pager and I'm going to choose my region as Europe.

Finally, you can click create app.

Once that part is done, you simply need to follow the instructions right here.

First, you need to download and install the Heroku Cli.

If you haven't already, you just need to click that link, scroll down and download and install it for your own operating system.

Now that you have downloaded and installed the Heroku Cli, we can run the command Heroku Login back in our code, We can open up our terminal, and then I'm going to stop both servers from running by pressing Ctrl C and then Y.

Now I'm going to delete one and clear the server.

Okay, now we are on the medical pager forward slash Server.

So make sure that you're on the server directory.

We can Cd one time and now if we do Ls, you'll see that we have client and server.

Make sure that you Cd into server because right now we are deploying the back end.

So now let's run Heroku Login and then press enter.

You will be prompted to log into Heroku Cli.

So click login and then you can close that page and go back to the code.

There we go, we are logged in.

It might be a good idea to put the editor on the side so that we can view both the instructions and the terminal at the same time.

There we go, We've just run Heroku Login and then we have to simply run Git Init.

So right here, I'm going to run Git Init again, Make sure that you're in the server directory and then run Heroku, get remote and then a medical pager before you run git Add, make sure to go to your server and then right there, add, git, ignore.

So right here, let's add a dot, git ignore file.

Inside of here, you can simply type node underscore modules.

This is going to make sure to ignore the node modules and they are not going to be pushed to Heroku.

Now that we've done that, we can run, Git, Add, and finally git commit and they say make it better.

We definitely will.

Now that that is done, we can simply run Git, Push Heroku Master.

It's going to take about half a minute and your project should be up and running on the web.

There we go.

The application is live, we can go back to our medical pager and simply click open app and if you see the hello World in little letters at the top left, that means that we reached our endpoint on our server and if this route works, all of the other ones are working as well.

Great! Now we have this backend url.

that's your entire backend url and we need to connect that to stream and also to our front end.

So let's first go to our stream in here.

we'll have to go to chat and then overview.

We'll have to scroll down and we'll have to enter the url under the webhook url.

This is going to allow us to send Sms messages.

Great! Simply do it like this without the forward slash at the end and paste it.

Finally, you have to click save.

Let's open up our frontend code.

We can go to the client source and that's going to be inside of the components and then auth inside of here.

You can see that we have our own localhost 5000.

so paste your new url right here and make sure to have the odd at the end.

For me, that's going to be medical pager Heroku app.com forward slash auth that's the new server url we want to make the requests to Great! We are going to deploy the frontend part using Netlify.

We can go to login or sign up and once you're in your account you'll be able to click sites and then here you'll be able to drag and drop your build folder.

So how can we create a build? Well, let's open up our terminal and this time we'll have to be in the client side.

So click Cd dot dot to get back to the root folder and then Cd client to get to our client side.

Now that you're here, simply run Npm, Run Build.

This is going to take about a minute and you should see a new build folder appear.

There we go.

If you can see this message, that means that the project has been built successfully.

Now we can right click the build folder and click reveal in file Explorer.

Once you do that, you can simply drag and drop your build folder right here and it's going to be built right away As you can see, it took seconds.

We can go under domain settings and then options and edit the site name in.

Here you can do something like medical pager, but of course you can do anything that you prefer.

In this case, medical pager is taken.

So I'm just going to type Jsm and there we go.

Our website is now live.

There is our great form.

Let's try to log in as one of the users for example, Dr.

Smith, I'm going to enter his username and password and click sign in and there we go.

We are live.

But this is so exciting because this is now Live on the web.

That means that you can use this for your own purposes to create a group, chat with friends, colleagues, or anybody else.

You can create entire communities of people that can chat inside of this chat, create channels, direct messages, send Gifs, and do all that other good stuff.

Of course, all of this has been made possible by Stream.

So huge thanks to Stream, not only for sponsoring this video, but also for creating such a phenomenal piece of software that allows you to create chat applications and feeds professionally and scalably.

With that said, that's going to be the end of this video.

This was quite a long one.

So congratulations to you for coming to the end of this video and building this project out.

I'm sure you've learned a lot.

There are many more interesting projects coming up on the Js Mastery Pro platform, so if you're looking forward to that, definitely make sure to put your link into the mailing list to be sure to be notified.

Once again, thank you so much for watching! Stay healthy and see you in the next one.

